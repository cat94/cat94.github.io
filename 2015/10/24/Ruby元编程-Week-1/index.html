<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Ruby元编程 星期一 · 沈小黑的菜园</title><meta name="description" content="转入魔都啊哈~自从不做阿里实习生之后，在学校浑浑噩噩过了一周左右，终于又开始找实习~先投了猿题库，无奈要等到十月中旬才能面试，就先面了eBay，没想到还挺顺利地就过了，就这么当着杭州的二房东跑到上海开始实习生涯了~~P.S. 6号拿到offer13号入职，到现在才写下这段话的效率也是堪忧啊~

初遇"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Ruby元编程 星期一</a></h3></div><div class="post-content"><h1 id="转入魔都"><a href="#转入魔都" class="headerlink" title="转入魔都"></a>转入魔都</h1><p>啊哈~自从不做阿里实习生之后，在学校浑浑噩噩过了一周左右，终于又开始找实习~先投了猿题库，无奈要等到十月中旬才能面试，就先面了eBay，没想到还挺顺利地就过了，就这么当着杭州的二房东跑到上海开始实习生涯了~~<br>P.S. 6号拿到offer13号入职，到现在才写下这段话的效率也是堪忧啊~</p>
<a id="more"></a>
<h1 id="初遇Ruby"><a href="#初遇Ruby" class="headerlink" title="初遇Ruby"></a>初遇Ruby</h1><p>说是Ruby元编程，是打算写下读《Ruby元编程》的一些笔记，但是在这之前，还是要先讲讲怎么会开始学习Ruby了呢~</p>
<p>10月13日，那是一个风和日丽的早晨。来到eBay之前就风闻是个很闲适的公司，闲适到七爷得知我到eBay实习后的第一回应就是“哦！很清闲！”。当主管和我聊到需要做的事情的时候，才知道需要使用Ruby开发，说实话心里还有点小激动“早听说Ruby很厉害，我要成为那个不拘一格的一员了么~”。其实一般都会有这样的心态：使用越小众的语言就显得越厉害…当然残存的理智告诉我，程序员是不可能因为换个语言而变厉害的，更何况一个连Java都谈不上精通的程序员。</p>
<p>学之前还是挺忐忑的，但是我那慵懒的，十二点左右上班，六点左右下班的mentor跟我说“这玩意儿很简单的，你随便看看就会了”。于是我收拾心情，花了一个晚上看了一下Ruby语法，诶~感觉跟python还蛮像的，可能还真的很简单呢！</p>
<p>就这样，我要开始我的Ruby学习之旅了~！<br><s>上面这样的句式总是会让人感觉你现在已经是某某的大师，其实我现在还什么都不懂哈哈！</s></p>
<h1 id="Ruby元编程"><a href="#Ruby元编程" class="headerlink" title="Ruby元编程"></a>Ruby元编程</h1><p>好了，终于开始正篇。</p>
<p>其实一个语言的语法很简单，有一本书大致叫《七天学习七门语言》，讲的就是七天内掌握七门语言的语法，这对于熟悉一门编程语言的人来说其实并不难。但语言的精髓其实在于它的设计思想，当真正领会了一门语言的设计思想之后，我想以后学习其他语言的时候，不仅能很快掌握语法，更能迅速地利用这门语言的特性写出优秀的代码吧。所以在看了“Ruby菜鸟教程”这种语法科普之后，我就开始看《Ruby元编程》啦，因为是松本行弘本人写的，看网上的评价也非常好，所以…希望能从中一窥Ruby号称的“元编程”到底比起Java等语言神奇在何处。</p>
<p>《Ruby元编程》其实是一个故事…书中主人公跟我一样是一个刚进公司的实习生，和他结对编程兼任mentor的是一个Ruby大师~然后他们的故事以一天为一章…其实书很薄，当然也要看有没有足够的时间，所以~就按照章节来写笔记吧。</p>
<p>今天是“星期一”。</p>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>在很多语言，比如C++中，语言构件(变量、类、方法等)在编译器完成工作之后，就变成了看不见摸不着的东西，只是内存位置而已。</p>
<p>而在Ruby和其他很多语言中，运行时绝大多数的语言构件依然存在。可以从构件处获得关于它自己的信息。这称为内省。</p>
<p>内省的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(text)</span></span> </div><div class="line">		@text = text </div><div class="line">	<span class="keyword">end</span>  </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">welcome</span> </span></div><div class="line">		@text </div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span> </div><div class="line"></div><div class="line">my_obj = Greeting.new(<span class="string">"Hello"</span>)</div><div class="line"></div><div class="line"></div><div class="line">puts my_obj.<span class="keyword">class</span> ,my_obj.<span class="keyword">class</span>.instance_methods(<span class="literal">false</span>) ,my_obj.instance_variables</div></pre></td></tr></table></figure>
<p>通过这样的代码，就可以获得关于对象本身的很多信息。这样说来，Java也是内省的语言。</p>
<p>C在运行时中，只有一大堆机器码。在C++中，一些语言构件可以在编译后留下来。Java中，编译时和运行时界限十分模糊，可以有足够的内省能力来列出一个类的方法和继承关系等。</p>
<p>最彻底的是Ruby，Ruby中没有编译时的概念，所有的构件都在运行时可用。</p>
<h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>比起内省，元编程更进一步，它允许对语言构件进行修改，举个例子：</p>
<p>在Java中， 假如想要写一个DBModel，必须要把数据库中的字段都一一对应写在类中，并添加getter和setter。而在数据库字段发生改变的时候，还必须相应地改变类的实例变量和对应的实例方法。而在Ruby中，只要写出如下的代码，就可以自动完成数据表的映射：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span> &lt; ActiveRecord::Base</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样就能直接使用Movie#title()来访问title字段。这些方法和变量都没有定义过，那么ActiveRecorder是怎么实现的呢？</p>
<p>因为类名是Movie，ActiveRecord会把它映射到名为movies的表中。而那些访问属性的方法，是ActiveRecord从表模式中得到字段名后，自动定义的方法。</p>
<p>写入语言构件的能力就在这时候发挥作用了，至于这种能力是怎么实现的，在后面的书中会进行讲解。</p>
<blockquote>
<p>元编程是编写在运行时操纵语言构件的代码。</p>
</blockquote>
<p>这就是元编程的概念~</p>
<h2 id="Open-Class特性"><a href="#Open-Class特性" class="headerlink" title="Open Class特性"></a>Open Class特性</h2><p>Open Class特性<br>在Ruby中，第二次定义一个类只会修改已经存在的类，比如：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span></span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span></span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样的话，D就有x和y两个方法了。</p>
<p>值得注意的是…这样很可能导致原来其他地方使用的方法被重写，从而导致运行出现问题。这是Open Class的隐患，经常被称作猴子补丁  Monkeypatch</p>
<p>为了避免猴子补丁的问题，我们可以将类放在模块中，这样就能很大程度上避免命名冲突了。(还是有可能会发生问题：只要两处的模块名相同且类名相同，就依然会有猴子补丁的问题)</p>
<p>另外还有其他的解决方案，选择子空间等等…当然，书中的mentor说在书后面会讲到，那就后面看到再说吧~</p>
<h2 id="Ruby类的真相"><a href="#Ruby类的真相" class="headerlink" title="Ruby类的真相"></a>Ruby类的真相</h2><p>在Ruby这样的动态语言中，对象的类和实例变量没有关系，当给实例变量赋值时，它们就生成了。如下例，输出是如果不曾调用my_method，那么输出的变量列表就是空</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span> </span></div><div class="line">		@v=<span class="number">1</span> </div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span> </div><div class="line"></div><div class="line">obj = MyClass.new  </div><div class="line">puts obj.instance_variables</div></pre></td></tr></table></figure>
<p>实例变量存放在对象中，而方法(包括类方法和对象的方法)放在类中。</p>
<p>类自身也是对象。类自身的类叫做Class.<br>在这里类是一个对象，那么这个对象的类：Class也就拥有了这个对象的实例方法。所以一个类的方法就是Class的实例方法。</p>
<img title="类继承关系" alt="类继承关系" src="http://7xltls.com1.z0.glb.clouddn.com/images/ruby/MetaProgramming/week1/类继承关系.jpg">
<p>Class的superclass是Module<br>Module的superclass时Object<br>Object的superclass是BasicObject……MyClass<br>BasicObject的superclass是nil</p>
<p>因此，Class只不过是在Module的基础上增加了new、allocate和superclass这三个方法的增强模块罢了。</p>
<p>可是运行Module.methods可以找到这三个方法？</p>
<blockquote>
<p>首先,methods,private_methods是Object类的实例方法;instance_methods是Module类的实例方法。<br>Ruby对象可以分为2类，一类是普通对象，还有一类对象是类(类本身也是一种对象),像String,Class这种类，这种对象叫类对象。<br>普通对象的祖先链，以”abc”为例，为String-&gt; Comparable-&gt;Object-&gt;Kernel-&gt; BasicObject<br>类对象的祖先链,以String为例,为Class-&gt;Module-&gt;Object-&gt;Kernel-&gt; BasicObject<br>我们可以看到普通对象是没有instance_methods方法的，因为其祖先链上没有Module类。所以对于一个普通对象，我们只能说它有方法或私用方法，而不能说它有实例方法，实例方法是对一个类来说的。<br>(引用自slef-motivation的博客<a href="http://blog.csdn.net/happyanger6/article/details/42436879" target="_blank" rel="external">http://blog.csdn.net/happyanger6/article/details/42436879</a>)</p>
</blockquote>
<p>所以运行Module.methods找到的是Object类中的方法，那时候自然会有这三个方法。在Module.instance_methods中就找不到这三个方法了。</p>
<p>Module类提供了两个constants()方法，实例方法Module#constants()返回当前范围内的常量，而类方法Module.constants()返回当前程序中所有的顶级常量，包括类名。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module MyClass   AAA = 'aaa'   def my_method  @v=1  end end  </div><div class="line">MyClass.constsants #返回AAA</div><div class="line">Module.constants 	#返回Object，Module，Class，BasicObject......MyClass。这些都是顶级常量(类名也是顶级常量)，而AAA由于不是顶级的常量，所以没有被列在里面</div></pre></td></tr></table></figure>
<p>当在一个类中包含一个模块时，Ruby创建了一个封装该模块的匿名类，并把这个匿名类插入到祖先链中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span>  </span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span>   </span></div><div class="line">	<span class="keyword">end</span> </div><div class="line"><span class="keyword">end</span>  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  </span></div><div class="line">	<span class="keyword">include</span> M </div><div class="line"><span class="keyword">end</span>  </div><div class="line"></div><div class="line">puts C.ancestors</div></pre></td></tr></table></figure>
<p>结果输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C</div><div class="line">M</div><div class="line">Object</div><div class="line">Kernel</div><div class="line">BasicObject</div></pre></td></tr></table></figure>
<p>祖先链会包含模块，在这里是M和Kernel</p>
<p>那么Kernel模块又是什么呢？</p>
<p>Ruby中有像print()这类方法，我们可以在任何代码空间中调用它们，这实际上都是Kernel模块的私有方法。Object类包含了Kernel模块，而Object类是任何类的superclass，所以任何类都会包含Kernel模块，也就有了Kernel内的私有方法。</p>
<h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>由于对象和类的方法分开，对象必须要有一个self引用才能让方法知道当前调用者是谁。</p>
<p>通常self是最后一个接收到方法调用的对象，但是当在类和模块中定义时，self的角色由类/模块担任。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">    <span class="keyword">self</span>                    <span class="comment"># =&gt; MyClass</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>所以在类中定义方法前加上self就是类方法/单例方法了，因为这时self是类自己</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">claz_method</span></span></div><div class="line">    p <span class="string">'this is a class method'</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyClass.claz_method</div><div class="line"></div><div class="line">puts MyClass.singleton_methods(<span class="literal">false</span>)  <span class="comment"># =&gt; claz_method</span></div></pre></td></tr></table></figure>
<h2 id="Ruby中特殊的private规则"><a href="#Ruby中特殊的private规则" class="headerlink" title="Ruby中特殊的private规则"></a>Ruby中特殊的private规则</h2><p>Ruby中不允许明确指定一个接收者来调用一个私有的方法。换言之，每次调用一个私有方法时，只能调用于隐含的接收者——self上。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>  </span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">public_method</span>  </span></div><div class="line">		<span class="keyword">self</span>.private_method </div><div class="line">	<span class="keyword">end</span>   </div><div class="line">	</div><div class="line">	private  </div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">private_method</span>   </span></div><div class="line">	<span class="keyword">end</span> </div><div class="line"><span class="keyword">end</span>   </div><div class="line"></div><div class="line">C.new.public_method</div></pre></td></tr></table></figure>
<p>就算这样，指定self，依然会调用失败，因为要求只能调用于隐含的self。</p>
<h2 id="关于self的一个案例"><a href="#关于self的一个案例" class="headerlink" title="关于self的一个案例"></a>关于self的一个案例</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Printable</span>  </span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print</span></span></div><div class="line">	  puts <span class="string">'print in Printable'</span></div><div class="line">	<span class="keyword">end</span> </div><div class="line"><span class="keyword">end</span>  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Document</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_to_screen</span></span></div><div class="line">    print </div><div class="line">  <span class="keyword">end</span>   </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span>  </span></div><div class="line">    puts <span class="string">'print in document'</span>  </div><div class="line">  <span class="keyword">end</span> </div><div class="line"><span class="keyword">end</span>  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>  </span></div><div class="line">	<span class="keyword">include</span> Document  </div><div class="line">	<span class="keyword">include</span> Printable </div><div class="line"><span class="keyword">end</span>   </div><div class="line"></div><div class="line">Book.new.print_to_screen</div></pre></td></tr></table></figure>
<p>这里的输出结果是”print in Printable”</p>
<p>因为祖先链是：[Book, Printable, Document, Object , Kernel, BasicObject]</p>
<p>所以self在print_to_screen中寻找print方法时，由于self所属的Book类没有print方法，所以向从Book类向上寻找，而到Printable就已经找到方法了，就会调用Printable中的print方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这就是今天的《Ruby元编程》抄写情况，谢谢观看~</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-10-24</span><i class="fa fa-tag"></i><a href="/tags/Ruby/" title="Ruby" class="tag">Ruby </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2015/10/24/Ruby元编程-Week-1/,沈小黑的菜园,Ruby元编程 星期一,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/10/24/Ruby元编程-Week-2/" title="Ruby元编程 星期二" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/10/02/机器学习-ex6/" title="机器学习 ex6" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>