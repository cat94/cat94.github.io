<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Ruby元编程 星期三 · 沈小黑的菜园</title><meta name="description" content="代码块块可以用来控制作用域，它只是Ruby中“可调用对象”的一种，还有其他的可调用对象，比如proc和lambda。在这一章将会学习怎样利用这些对象来进行元编程。
前面两章的内容跟普通的面向对象没有很大的区别，但是代码块源于函数式编程语言，所以会带有函数式编程独特的思考角度~

块基础在Ruby中块"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Ruby元编程 星期三</a></h3></div><div class="post-content"><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>块可以用来控制作用域，它只是Ruby中“可调用对象”的一种，还有其他的可调用对象，比如proc和lambda。在这一章将会学习怎样利用这些对象来进行元编程。</p>
<p>前面两章的内容跟普通的面向对象没有很大的区别，但是代码块源于函数式编程语言，所以会带有函数式编程独特的思考角度~</p>
<a id="more"></a>
<h1 id="块基础"><a href="#块基础" class="headerlink" title="块基础"></a>块基础</h1><p>在Ruby中块是指大括号{}或者do…end之间的代码块，只有在调用一个方法时，才可以定义一个块。块会被传递给这个方法，该方法可以使用yield调用这个块。</p>
<p>使用yield调用代码块的例子：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</div><div class="line">  <span class="string">'no block'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">p a_method      <span class="comment">#=&gt; no block</span></div><div class="line">p a_method&#123;<span class="string">'The block !'</span>&#125;  <span class="comment">#=&gt; the block!</span></div></pre></td></tr></table></figure>
<p>在Java中，有内部作用域的概念，在内部作用域可以看到外部作用域的变量。但是Ruby没有这种嵌套式的作用域，一旦进入新的作用域，原来的绑定就会被替换成一组新的绑定。这意味着在如下的代码中，v1在MyClass的作用域之外，一旦进入MyClass之后v1就不可见了。但是全局变量是可以跨越作用域的~~</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">v1 = <span class="number">1</span></div><div class="line">$v2 = <span class="number">2</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  v3 = <span class="number">3</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_v1</span></span></div><div class="line">    p v1</div><div class="line">  <span class="keyword">end</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print_v2</span></span></div><div class="line">  	 p v2</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">MyClass.new.print_v1    <span class="comment">#=&gt; Error!</span></div><div class="line">MyClass.new.print_v2    <span class="comment">#=&gt;2</span></div></pre></td></tr></table></figure>
<p>如果觉得全局变量无法控制，那么可以使用顶级实例变量，这样只要main对象扮演self对象就可以访问，而当其他对象成为self时，就不能够看见顶级实例变量了。但是这种安全性也是有限的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@var = <span class="string">"The top-level @var"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">	@var</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">my_method		<span class="comment"># =&gt; "The top-level <span class="doctag">@var</span>"，因为这时的self还是main</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">		@var = <span class="string">"This is not the top-level @var!"</span></div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h1 id="作用域门与扁平化作用域"><a href="#作用域门与扁平化作用域" class="headerlink" title="作用域门与扁平化作用域"></a>作用域门与扁平化作用域</h1><p>Ruby中程序会在三个地方关闭前一个作用域，同时打开一个新作用域：</p>
<ul>
<li>类定义</li>
<li>模块定义</li>
<li>方法</li>
</ul>
<p>有时候会想要知道怎么才能让绑定穿越作用域门：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my_var = <span class="string">"Success"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="comment"># 希望在这里打印 my_var</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">		<span class="comment"># ...还有这里</span></div><div class="line">	<span class="keyword">end</span></div><div class="line">	</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>class是作用域门，我们能想的就是用非作用域门，比如方法调用来代替作用域门。从Ruby文档可以知道(书上写的，我就查看了一下文档)</p>
<blockquote>
<p>Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). You can give a class a name by assigning the class object to a constant.<br>If a block is given, it is passed the class object, and the block is evaluated in the context of this class using class_eval.</p>
</blockquote>
<p>也就是说Class.new可以用来达到跟class关键字一样的效果，但是它是方法调用，不会造成作用域分隔。类似的，可以使用动态方法来代替def关键字：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">my_var = <span class="string">"Success"</span></div><div class="line"></div><div class="line">MyClass = Class.new <span class="keyword">do</span></div><div class="line">	</div><div class="line">	puts <span class="string">"<span class="subst">#&#123;my_var&#125;</span> in the class definition!"</span></div><div class="line">	</div><div class="line">	define_method <span class="symbol">:my_method</span> <span class="keyword">do</span></div><div class="line">		puts <span class="string">"<span class="subst">#&#123;my_var&#125;</span> in the method!"</span></div><div class="line">	<span class="keyword">end</span></div><div class="line">	</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这种使用方法调用来代替作用域门的方法，称为扁平化作用域。</p>
<h2 id="共享作用域"><a href="#共享作用域" class="headerlink" title="共享作用域"></a>共享作用域</h2><p>有了扁平作用域之后，就拥有了控制作用域的能力。假如想在一组方法之间共享一个变量而不希望其他方法能访问这个变量，就可以把这个方法定义在那个变量所在的扁平作用域中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">define_methods</span></span></div><div class="line">  shared = <span class="number">0</span></div><div class="line">  Kernel.send <span class="symbol">:define_method</span>, <span class="symbol">:counter</span> <span class="keyword">do</span></div><div class="line">    shared</div><div class="line">  <span class="keyword">end</span></div><div class="line">  Kernel.send <span class="symbol">:define_method</span>, <span class="symbol">:inc</span> <span class="keyword">do</span> <span class="params">|x|</span></div><div class="line">    shared += x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">define_methods</div></pre></td></tr></table></figure>
<p>这个例子定义了两个内核方法，还使用动态派发来访问Kernel的私有方法define_method。现在counter和inc方法都能看到shared变量，但是其他方法却看不到它。</p>
<p>通过作用域门、扁平作用域和共享作用域之后，就可以在任何地方看到希望看到的变量了。</p>
<h1 id="instance-eval方法"><a href="#instance-eval方法" class="headerlink" title="instance_eval方法"></a>instance_eval方法</h1><p>instance_eval是BasicObject类的方法，它将在一个对象的上下文中执行块，也可以看到在代码块中变量定义时的绑定，就像下面代码中的v一样。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @v = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = MyClass.new</div><div class="line"></div><div class="line">obj.instance_eval <span class="keyword">do</span></div><div class="line">  @v      <span class="comment"># =&gt; 1</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">v=<span class="number">2</span></div><div class="line">obj.instance_eval &#123; @v = v&#125;</div><div class="line">obj.instance_eval &#123; @v &#125;    <span class="comment"># =&gt; 2</span></div></pre></td></tr></table></figure>
<p>传递给instance_eval的代码块被称为上下文探针，因为这些代码块对对象进行操作。</p>
<h2 id="instance-exec方法"><a href="#instance-exec方法" class="headerlink" title="instance_exec方法"></a>instance_exec方法</h2><p>instance_exec方法与instance_eval方法类似，但是它还允许传入参数。<br>实例变量是依赖于当前对象self的，所以即使使用上下文探针，当instance_eval方法把接收者变为当前对象self的时候，调用者的实例变量就落在作用域范围外面了。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @x =<span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">twisted_method</span></span></div><div class="line">    @y = <span class="number">2</span></div><div class="line">    A.new.instance_eval &#123; <span class="string">"@x: <span class="subst">#&#123;@x&#125;</span>, @y: <span class="subst">#&#123;@y&#125;</span>"</span> &#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">B.new.twisted_method      <span class="comment"># =&gt; "<span class="doctag">@x</span>: 1, <span class="doctag">@y</span>: "</span></div></pre></td></tr></table></figure>
<p>在这里@y就因为在作用域外而被当成未定义的nil了。为了把@y放在一个作用域里面，可以使用instance_exec方法传递值：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @x =<span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">twisted_method</span></span></div><div class="line">    @y = <span class="number">2</span></div><div class="line">    A.new.instance_exec(@y) &#123;<span class="params">|y|</span> <span class="string">"@x: <span class="subst">#&#123;@x&#125;</span>, @y: <span class="subst">#&#123;y&#125;</span>"</span> &#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">p B.new.twisted_method      <span class="comment"># =&gt; "<span class="doctag">@x</span>: 1, <span class="doctag">@y</span>: 2"</span></div></pre></td></tr></table></figure>
<h2 id="洁净室"><a href="#洁净室" class="headerlink" title="洁净室"></a>洁净室</h2><p>如果只想要一个用来执行块的环境，那么就不应该有任何方法或变量，以免和块中的方法/变量产生冲突，因此，BasicObject类的实例通常充当洁净室，几乎不带有任何方法。在这样的洁净室中，一些像String的常量都必须用到绝对路径::String。</p>
<p>#可调用对象<br>代码块的机制是：“打包，调用”，而在Ruby中至少还有三种方法可以打包代码：</p>
<ul>
<li>使用proc，它是由块转换而来的对象</li>
<li>使用lambda，它是proc的变种</li>
<li>使用方法</li>
</ul>
<h2 id="Proc对象"><a href="#Proc对象" class="headerlink" title="Proc对象"></a>Proc对象</h2><p>如果我们想要存储一段代码怎么办呢？代码块并不是对象，所以不能赋给变量。为了解决这个问题，Ruby提供了名为Proc的类。我们通过可以把代码传给Proc.new来创建一个Proc，以后就可以用Proc#call来执行这个代码块了。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inc = Proc.new &#123;<span class="params">|x|</span> x+<span class="number">1</span> &#125;</div><div class="line">inc.call(<span class="number">2</span>)			<span class="comment"># =&gt; 3</span></div></pre></td></tr></table></figure>
<p>这样就可以达到延迟执行的效果</p>
<p>其他创建proc的方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用lambda</span></div><div class="line">dec = lambda &#123; <span class="params">|x|</span> x+<span class="number">1</span> &#125;</div><div class="line">dec.<span class="keyword">class</span>			<span class="comment"># =&gt; Proc</span></div><div class="line">dec.call(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 使用lambda操作符</span></div><div class="line">p = -&gt;(x) &#123; x+<span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">#使用&amp;操作符，在下一段讲解</span></div></pre></td></tr></table></figure>
<h3 id="amp-操作符"><a href="#amp-操作符" class="headerlink" title="&amp;操作符"></a>&amp;操作符</h3><p>在大多数情况下，传递给一个方法的代码块可以通过yield直接运行，就像一个匿名参数一样。但是在下面两种情况下就力不从心了，因为要实现这两个需求势必要求代码块有自己的名字：</p>
<ul>
<li>把代码块传递给另外一个方法/代码块</li>
<li>把代码块转换成Proc</li>
</ul>
<p>要将代码块附加到一个绑定上，可以通过给这个方法添加一个特殊的参数，它必须是参数列表的最后一个并且以&amp;开头。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">math</span><span class="params">(a, b)</span></span></div><div class="line">  <span class="keyword">yield</span>(a, b)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_math</span><span class="params">(a, b, &amp;operation)</span></span></div><div class="line">  math(a, b, &amp;operation)	<span class="comment">#将代码块传递给了另一个方法</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">do_math(<span class="number">2</span>, <span class="number">3</span>)&#123;<span class="params">|x,y|</span> x*y&#125;  <span class="comment"># =&gt; 6，这里的代码块就是&amp;operation参数</span></div></pre></td></tr></table></figure>
<p>&amp;符号的意思就是：这是一个Proc对象，我想把它当成代码块来使用。去掉&amp;符号之后，就能再次得到一个Proc对象。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">math</span><span class="params">(a, b)</span></span></div><div class="line">  <span class="keyword">yield</span>(a, b)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_math</span><span class="params">(a, b, &amp;operation)</span></span></div><div class="line">  math(a, b, &amp;operation)</div><div class="line">  operation.<span class="keyword">class</span>         <span class="comment"># =&gt; Proc</span></div><div class="line">  operation.call(<span class="number">1</span>,<span class="number">2</span>)     <span class="comment"># =&gt; 2</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">do_math(<span class="number">2</span>, <span class="number">3</span>)&#123;<span class="params">|x,y|</span> x*y&#125;  <span class="comment"># =&gt; 6</span></div></pre></td></tr></table></figure>
<h2 id="Proc与Lambda的对比"><a href="#Proc与Lambda的对比" class="headerlink" title="Proc与Lambda的对比"></a>Proc与Lambda的对比</h2><p>用lambda方法创建的Proc与其他方式创建的Proc有一些细微却重要的差别。用lambda方法(包括”-&gt;”操作符)创建的Proc称为lambda，而其他方式创建的称为proc。这里面有很多特例以及规则，下面是一些大概：</p>
<h3 id="不同的return含义"><a href="#不同的return含义" class="headerlink" title="不同的return含义"></a>不同的return含义</h3><p>在lambda中，return仅仅表示从lambda中返回，而在proc中则表示从定义proc的作用域中返回。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#lambda的return </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(callable_obj)</span></span></div><div class="line">  callable_obj.call() * <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">l = lambda&#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</div><div class="line">double(l)   <span class="comment"># =&gt; 20</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_double</span><span class="params">()</span></span></div><div class="line">  l = Proc.new&#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</div><div class="line">  result = l.call()</div><div class="line">  result * <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">another_double  <span class="comment"># =&gt; 10</span></div></pre></td></tr></table></figure>
<p>而像下面的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_double</span><span class="params">(callable_obj)</span></span></div><div class="line">  callable_obj.call *<span class="number">2</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">p = Proc.new &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;</div><div class="line">another_double(p)	<span class="comment"># =&gt; LocalJumpError</span></div></pre></td></tr></table></figure>
<p>因为上面的程序试图从定义p的作用域，也就是顶级作用域返回，而顶级作用域不能返回，所以就失败了，如果不使用return就不会出现这样的问题。</p>
<h3 id="Proc、Lambda和参数数量"><a href="#Proc、Lambda和参数数量" class="headerlink" title="Proc、Lambda和参数数量"></a>Proc、Lambda和参数数量</h3><p>在参数数量的问题上，lambda的适应能力比proc以及普通的代码块差。如果调用lambda时参数数量不对，就会抛出ArgumentError错误，而proc则会把传来的参数调整成期望的参数形式。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p = Proc.new &#123;<span class="params">|a,b|</span> [a, b]&#125;</div><div class="line">p.call(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) 	<span class="comment"># =&gt; [1, 2]</span></div><div class="line">p.call(<span class="number">1</span>)			<span class="comment"># =&gt; [1, nil]</span></div></pre></td></tr></table></figure>
<h2 id="Method对象"><a href="#Method对象" class="headerlink" title="Method对象"></a>Method对象</h2><p>通过Kernel.method方法，可以获得一个用Method对象表示的方法，并在以后用Method#call进行调用。还可以使用Kernel#sinleton_method把单例方法名转换成Method对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(value)</span></span></div><div class="line">    @x = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">    @x</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = MyClass.new(<span class="number">1</span>)</div><div class="line">m = obj.method <span class="symbol">:my_method</span></div><div class="line"></div><div class="line">m.call    <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>Method对象类似于Proc和lambda对象，可以通过Method#to_proc方法转换成Proc对象，也可以用define_method方法把代码块转换成方法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define_method(<span class="symbol">:print_m</span>, Proc.new &#123;<span class="params">|x|</span> p x&#125;)</div><div class="line"></div><div class="line">print_m <span class="string">'aaa'</span></div></pre></td></tr></table></figure>
<p>Method对象和lambda/Proc之间有一个重要的区别：lambda可以看到定义它的作用域，而Method对象只能看到自身的定义域。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">aa = <span class="string">'aaa'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method</span><span class="params">(str)</span></span></div><div class="line">  aa = str</div><div class="line"><span class="keyword">end</span></div><div class="line">my_m = method <span class="symbol">:my_method</span></div><div class="line"></div><div class="line">l = lambda&#123;<span class="params">|str|</span> aa = str&#125;</div><div class="line"></div><div class="line">proc = Proc.new &#123;<span class="params">|str|</span> aa = str&#125;</div><div class="line"></div><div class="line"></div><div class="line">my_m.call <span class="string">'bbb'</span></div><div class="line">p aa    <span class="comment"># =&gt; aaa</span></div><div class="line"></div><div class="line">l.call <span class="string">'ccc'</span></div><div class="line">p aa    <span class="comment"># =&gt; ccc</span></div><div class="line"></div><div class="line"></div><div class="line">proc.call <span class="string">'ddd'</span></div><div class="line">p aa    <span class="comment"># =&gt; ddd</span></div></pre></td></tr></table></figure>
<h3 id="自由方法"><a href="#自由方法" class="headerlink" title="自由方法"></a>自由方法</h3><p>自由方法是从类/模块中脱离的方法，可以通过调用Method#unbind或者Module#instance_method方法来获得一个自由方法(类名是UnboundMethod)。</p>
<p>UnboundMethod不能调用，但是可以通过UnboundMethod#bind或者Module#define_method(需要动态派发，因为是私有方法)把它自己绑定到一个对象上。从某一个类中分离出来的UnboundMethod对象只能被绑定到该类及其子类对象上，不过从某个模块中分离出来的UnboundMethod在Ruby2.0之后不受这个限制。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(value)</span></span></div><div class="line">    @x = <span class="number">1</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">    <span class="number">12</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassSon</span> &lt; MyClass</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">m = MyClass.new(<span class="number">1</span>).method <span class="symbol">:my_method</span></div><div class="line">m.unbind</div><div class="line"></div><div class="line">MyClassSon.send(<span class="symbol">:define_method</span>,<span class="symbol">:another_method</span>,m)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_method</span></span></div><div class="line">    <span class="number">42</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">unbound = MyModule.instance_method <span class="symbol">:my_method</span></div><div class="line">unbound.<span class="keyword">class</span>     <span class="comment"># =&gt; UnboundMethod</span></div><div class="line"></div><div class="line">String.send <span class="symbol">:define_method</span>, <span class="symbol">:another_method</span>, unbound</div><div class="line"></div><div class="line"><span class="string">"abc"</span>.another_method  <span class="comment"># =&gt; 42</span></div></pre></td></tr></table></figure>
<p>自由方法在极个别的场景下可以发挥特殊的作用，下面是书上的例子：</p>
<h4 id="Active-Support-例子"><a href="#Active-Support-例子" class="headerlink" title="Active Support 例子"></a>Active Support 例子</h4><p>在有些类库中实现了这样的功能：如果我们想在引用定义在某个文件中的常量时，自动加载该文件，这个自动加载系统中包含了一个Loadable模块，重新定义了标准的Kernel#load方法。有时我们希望消除自动加载功能，也就是使用标准的Kernel#load方法。但是Ruby中没办法将Loadable从祖先链中去除，但是却可以通过自由方法解决这个问题：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Loadable</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">exclude</span><span class="params">(base)</span></span></div><div class="line">		base.class_eval &#123;define_method(<span class="symbol">:load</span>, Kernel.instance_method(<span class="symbol">:load</span>))&#125;</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="keyword">include</span> Loadable</div><div class="line">	exclude(MyClass)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这样就会把Kernel#load拷贝到MyClass类中，从而让这个拷贝在祖先链中先于Loadable#load。</p>
<p>这是一个相当冷门的情况，其实大多数情况下自由方法都是用不着的+_+</p>
<h1 id="理解下面代码"><a href="#理解下面代码" class="headerlink" title="理解下面代码"></a>理解下面代码</h1><p>下面的一段代码是编写DSL的小测验中的一段代码，理解了它应该就差不多能理解那段代码了~</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">lambda&#123;</div><div class="line">  setups = []</div><div class="line">  Kernel.send <span class="symbol">:define_method</span>, <span class="symbol">:setup</span> <span class="keyword">do</span> <span class="params">|&amp;block|</span></div><div class="line">    setups &lt;&lt; block</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  Kernel.send <span class="symbol">:define_method</span> , <span class="symbol">:each_setup</span> <span class="keyword">do</span> <span class="params">|&amp;block|</span></div><div class="line">    setups.each <span class="keyword">do</span> <span class="params">|setup|</span></div><div class="line">      block.call setup</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">&#125;.call</div><div class="line"></div><div class="line"></div><div class="line">setup <span class="keyword">do</span></div><div class="line">  puts <span class="string">"initialize sky"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">each_setup <span class="keyword">do</span> <span class="params">|setup|</span></div><div class="line">  setup.call</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>这里的定义的each_setup代码段中有参数&amp;block,而代码段内部又嵌套了一个带参数的代码段。</p>
<p>下面来抽丝剥茧，其实最后的</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define_method(<span class="symbol">:each_method</span>, Proc.new &#123;<span class="params">|setup|</span> block.call setup&#125;)</div></pre></td></tr></table></figure>
<p>就是把setup当做block的参数来调用block方法。<br>那么再把最后的调用处代码代进去，就是把</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define_method(<span class="symbol">:m</span>, Proc.new&#123;<span class="params">|x|</span> x.call&#125;)</div></pre></td></tr></table></figure>
<p>代入each_setup，效果就是：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">each_setup</span></span></div><div class="line">	setups.each <span class="keyword">do</span> <span class="params">|setup|</span></div><div class="line">		m.call setup</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">#把setup放进m的内部展开也就是</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">each_setup</span></span></div><div class="line">	setups.each <span class="keyword">do</span> <span class="params">|setup|</span></div><div class="line">		setup.call</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-10-26</span><i class="fa fa-tag"></i><a href="/tags/Ruby/" title="Ruby" class="tag">Ruby </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2015/10/26/Ruby元编程-Week-3/,沈小黑的菜园,Ruby元编程 星期三,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/10/28/Ruby元编程-Week-4/" title="Ruby元编程 星期四" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/10/24/Ruby元编程-Week-2/" title="Ruby元编程 星期二" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>