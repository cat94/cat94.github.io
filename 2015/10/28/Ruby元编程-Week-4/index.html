<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Ruby元编程 星期四 · 沈小黑的菜园</title><meta name="description" content="类定义即将走进”Ruby对象模型最深暗的角落”…和Java不同，在Ruby中，定义类实际上就是在运行代码，这种思想催生了1、可以修改类的类宏 2、可以在其他方法前后封装额外代码的环绕别名。当然，因为类不过是增强的模块，所以这些知识也可以应用于模块。

当前类方法所属判断是依靠定义方法的所在self判"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Ruby元编程 星期四</a></h3></div><div class="post-content"><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>即将走进”Ruby对象模型最深暗的角落”…和Java不同，在Ruby中，定义类实际上就是在运行代码，这种思想催生了1、可以修改类的类宏 2、可以在其他方法前后封装额外代码的环绕别名。当然，因为类不过是增强的模块，所以这些知识也可以应用于模块。</p>
<a id="more"></a>
<h2 id="当前类"><a href="#当前类" class="headerlink" title="当前类"></a>当前类</h2><p>方法所属判断是依靠定义方法的所在self判断的，所以对于父类定义的方法，即使在子类中运行使得m2定义语句得到运行，m2依然属于父类。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m1</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m2</span></span></div><div class="line"></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">p C.instance_methods(<span class="literal">false</span>)	<span class="comment"># =&gt; [:m1]</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;C</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">D.new.m1</div><div class="line"></div><div class="line">p C.instance_methods(<span class="literal">false</span>)	<span class="comment"># =&gt; [:m1, :m2]</span></div><div class="line"></div><div class="line">p D.instance_methods(<span class="literal">false</span>)	<span class="comment"># =&gt; []</span></div></pre></td></tr></table></figure>
<h3 id="class-eval-V-S-class关键字"><a href="#class-eval-V-S-class关键字" class="headerlink" title="class_eval V.S class关键字"></a>class_eval V.S class关键字</h3><p>使用class关键字修改类需要指定类名才可以，那假如想要将类名作为参数来动态修改某个类呢？这时候可以用到Module#class_eval(别名为module_eval)方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_method_to</span><span class="params">(a_class)</span></span></div><div class="line">  a_class.class_eval <span class="keyword">do</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span></span></div><div class="line">      <span class="string">'Hello!'</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">add_method_to String</div><div class="line">p <span class="string">"abc"</span>.m			<span class="comment"># =&gt; "Hello!"</span></div></pre></td></tr></table></figure>
<p>另外，class是一个作用域门，类外的变量对类里面来说是不可见的。而class_eval则使用扁平作用域，因为它归根结底只是一个方法调用。</p>
<p>可以发现class_eval和instance_eval很相似，class_eval也有带参数版本class_exec。instance_eval的重点在于修改对象中变量的当前self，使其在调用处可见，而class_eval的重点在于修改类。</p>
<h2 id="类的实例变量"><a href="#类的实例变量" class="headerlink" title="类的实例变量"></a>类的实例变量</h2><p>Ruby的实例变量属于当前self,所以在类中的方法外定义的实例变量属于类这个对象而不是类的实例。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">  @var = <span class="number">1</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span>;</span> @var; <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span>;</span> @var = <span class="number">2</span>; <span class="keyword">end</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">read</span>;</span> @var; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;A</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">read</span>;</span> @var; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = A.new</div><div class="line">p obj.read      <span class="comment"># =&gt; nil</span></div><div class="line">p B.read		    <span class="comment"># =&gt; nil</span></div><div class="line">obj.write</div><div class="line">p obj.read      <span class="comment"># =&gt; 2</span></div><div class="line">p A.read        <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>正因为实例变量的归属根据当前self判断，所以子类、实例都不能访问类实例变量，因为这个变量属于“类”这个对象的self。</p>
<p>注意和@@开头的类变量区别开来，它是可以被当前类和子类或实例访问的。正是因为这样，在顶级作用域定义类变量时，所有类都可以访问到它，因为它们都在顶级作用域的覆盖下。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@@var = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">	@@var = <span class="number">2</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">@@var = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>为了避免这样的情况，可以的话最好避免使用类变量，转而使用类的实例变量。</p>
<h2 id="单件方法"><a href="#单件方法" class="headerlink" title="单件方法"></a>单件方法</h2><p>Ruby支持给单个对象添加方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">str = <span class="string">"this is a string"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str</span>.<span class="title">title?</span></span></div><div class="line">	<span class="keyword">self</span>.upcase == <span class="keyword">self</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">str.singleton_methods  		<span class="comment"># =&gt; [:title?]</span></div></pre></td></tr></table></figure>
<p>和Java中singleton类只允许生成同一个对象的概念有所不同，这里的singleton方法是说这个方法只属于定义它的对象。</p>
<p>实际上，联想到定义类方法时的方法名前的self，类方法其实就是Class对象的单件方法罢了。</p>
<h2 id="类宏"><a href="#类宏" class="headerlink" title="类宏"></a>类宏</h2><p>Ruby对象没有属性，所以需要写类似Java的getter和setter才能访问或修改属性。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_attribute=</span><span class="params">(value)</span></span></div><div class="line">    @my_attribute = value</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">my_attribue</span></span></div><div class="line">    @my_attribute</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = MyClass.new</div><div class="line">obj.my_attribute = <span class="number">1</span></div><div class="line">obj.my_attribute     <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>但是这样写很烦，一点也不酷~ 所以Ruby提供了Module#attr_reader、Module#attr_writer和Module#attr_accessor</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:my_attribute</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = MyClass.new</div><div class="line">obj.my_attribute = <span class="number">1</span></div><div class="line">obj.my_attribute     <span class="comment"># =&gt; 1</span></div></pre></td></tr></table></figure>
<p>类似attr_accessor这样的方法就叫做类宏，他们看起来像是关键字，实际上只是可以用在类里的方法。</p>
<p>假设需要更新API，将旧的方法声明为deprecated，并且自动转到新方法，那么可以使用像下面这样的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">deprecate</span><span class="params">(old_method, new_method)</span></span></div><div class="line">    define_method(old_method) <span class="keyword">do</span> <span class="params">|*args, &amp;block|</span></div><div class="line">      warn <span class="string">"Warinig, <span class="subst">#&#123;old_method&#125;</span> is deprecated, use <span class="subst">#&#123;new_method&#125;</span> now!"</span></div><div class="line">      send(new_method,*args,&amp;block)</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">old_m</span></span></div><div class="line">    p <span class="string">"old"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">new_m</span></span></div><div class="line">    p <span class="string">"new"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  deprecate <span class="symbol">:old_m</span>, <span class="symbol">:new_m</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">obj = MyClass.new</div><div class="line">obj.old_m</div></pre></td></tr></table></figure>
<h2 id="单件类"><a href="#单件类" class="headerlink" title="单件类"></a>单件类</h2><p>Ruby查找方法时先进入接收者的类，然后再向上查找。比如一个MyClass类实例obj调用方法，就会进入obj的类MyClass来查找方法。但是单件方法肯定不在类里，否则所有对象都有这个方法了。而对象本身又不是一个类，所以也不在obj里。那么这个方法在哪里呢？</p>
<h3 id="什么是单件类"><a href="#什么是单件类" class="headerlink" title="什么是单件类"></a>什么是单件类</h3><p>当询问对象的类时，Ruby返回的其实不是看到的类，而是对象特有的隐藏类。这个类被称为这个对象的单件类，或者叫元类。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">obj = Object.new</div><div class="line">singleton_class = <span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></div><div class="line">                    <span class="keyword">self</span>      <span class="comment"># =&gt; #&lt;Class:#&lt;Object:0x007fcc711e4278&gt;&gt;</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">p singleton_class</div></pre></td></tr></table></figure>
<p>这样我们就可以看到这个单件类的引用(.class方法会包装隐藏单件类)，现在Ruby也提供.singleton_class方法返回单件类。每个对象都有自己的单件类，单件类也只有一个实例(有实例说明它的实例也有自己的单件类~循环往复……只是这个单件类的单件类的用途还没有被开发过)。对象的单件方法就放在对应的单件类中。</p>
<p>现在需要更新一下在星期一学习的继承模型了：obj所在的类是obj的单件类，单件类的父类才是MyClass,MyClass类对象的父类是Object。<br><img title="单件类的方法查找" alt="单件类的方法查找" src="http://7xltls.com1.z0.glb.clouddn.com/images/ruby/MetaProgramming/week4/单件类的方法查找.jpg"></p>
<h3 id="单件类和继承"><a href="#单件类和继承" class="headerlink" title="单件类和继承"></a>单件类和继承</h3><p>假设有如下的类关系，我们可以通过观察继承树输出来了解他们的结构关系</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">claz_method</span></span></div><div class="line"></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;C</span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = D.new</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj</span>.<span class="title">singleton_mtd</span></span></div><div class="line"></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line">p C.singleton_class       <span class="comment"># =&gt; #&lt;Class:C&gt;</span></div><div class="line">p D.singleton_class       <span class="comment"># =&gt; #&lt;Class:D&gt;</span></div><div class="line">p D.singleton_class.superclass  <span class="comment"># =&gt; #&lt;Class:C&gt;</span></div><div class="line">p C.singleton_class.superclass  <span class="comment"># =&gt; #&lt;Class:Object&gt;</span></div><div class="line">p BasicObject.singleton_class.superclass  <span class="comment"># =&gt; Class</span></div></pre></td></tr></table></figure>
<img title="单件类的继承关系" alt="单件类的继承关系" src="http://7xltls.com1.z0.glb.clouddn.com/images/ruby/MetaProgramming/week4/单件类的继承关系.jpg">
<h3 id="instance-eval和单件类的关系"><a href="#instance-eval和单件类的关系" class="headerlink" title="instance_eval和单件类的关系"></a>instance_eval和单件类的关系</h3><p>instance_eval方法会把当前类修改为接收者的单件类。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">s1 = <span class="string">'abc'</span></div><div class="line"></div><div class="line">s1.instance_eval <span class="keyword">do</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">swoosh!</span>;</span> reverse; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>很少会这样用，但这样是可以的。instance_eval的标准含义还是：修改self作用域内容。</p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>如果想给类创建属性的话，可以使用下面这样的形式：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="class"><span class="keyword">class</span> &lt;&lt; self</span></div><div class="line">		<span class="keyword">attr_accessor</span> <span class="symbol">:c</span></div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>因为如果在单件类中定义了方法，这些方法实际上就会成为类方法。而属性其实就是一对方法，所以这样就达到了类属性的效果。</p>
<h3 id="类扩展-对象扩展"><a href="#类扩展-对象扩展" class="headerlink" title="类扩展/对象扩展"></a>类扩展/对象扩展</h3><p>如果想要从一个Module中导入一个方法到类/对象中，可以打开这个类/对象，然后通过include模块来扩展方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">'hello'</span>; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="class"><span class="keyword">class</span> &lt;&lt; self</span></div><div class="line">		<span class="keyword">include</span> MyModule</div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyClass.my_method		<span class="comment">#完成了类方法的扩展</span></div><div class="line"></div><div class="line">obj = Object.new</div><div class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></div><div class="line">	<span class="keyword">include</span> MyModule</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj.my_method				<span class="comment">#完成了对象方法的扩展</span></div><div class="line">obj.singleton_methods	<span class="comment"># =&gt; [:my_method]</span></div></pre></td></tr></table></figure>
<p>除了使用打开类/对象，还可以使用简单的Object#extend方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyModule</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">'hello'</span>; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = Object.new</div><div class="line">obj.extend MyModule</div><div class="line">obj.my_method		<span class="comment"># =&gt; 'hello'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	extend MyModule</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">MyClass.my_method	<span class="comment"># =&gt; 'hello'</span></div></pre></td></tr></table></figure>
<h2 id="方法包装器"><a href="#方法包装器" class="headerlink" title="方法包装器"></a>方法包装器</h2><p>如果一个不能修改的接口(比如在库中)有很多地方都被使用，而又想要在所有使用这个接口的地方增加新功能，那找到所有使用接口的地方逐条修改就会变成一件痛苦的事情。Ruby为我们提供了方法包装器的技巧来解决这个问题。</p>
<h3 id="方法别名"><a href="#方法别名" class="headerlink" title="方法别名"></a>方法别名</h3><p>使用alias可以为Ruby方法起别名，只要不在顶级作用域里面，可以使用Module#alias_method方法，而在顶级作用域里面，只能使用alias关键字。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">my_method</span>;</span> <span class="string">'my_method()'</span>; <span class="keyword">end</span></div><div class="line">	alias_method <span class="symbol">:m</span>, <span class="symbol">:my_method</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">obj = MyClass.new</div><div class="line">obj.my_method		<span class="comment"># =&gt; 'my_method()'</span></div><div class="line">obj.m				<span class="comment"># =&gt; 'my_method'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_method2</span></span></div><div class="line">  <span class="string">'hello'</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">alias</span> <span class="symbol">:m2</span> <span class="symbol">:my_method2</span></div><div class="line"></div><div class="line">m2					<span class="comment"># =&gt; 'hello'</span></div></pre></td></tr></table></figure>
<p>如果原方法在设置了别名之后又被修改了，那么别名指向的还是未被修改时的代码。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></div><div class="line">	alias_method <span class="symbol">:real_length</span>, <span class="symbol">:length</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">length</span></span></div><div class="line">		real_length &gt; <span class="number">5</span> ? <span class="string">'long'</span> : <span class="string">'short'</span></div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="string">"War and Peace"</span>.length 		<span class="comment"># =&gt; "long"</span></div><div class="line"><span class="string">"War and Peace"</span>.real_length 	<span class="comment"># =&gt; 13</span></div></pre></td></tr></table></figure>
<h3 id="不同的方法包装器"><a href="#不同的方法包装器" class="headerlink" title="不同的方法包装器"></a>不同的方法包装器</h3><h4 id="环绕别名"><a href="#环绕别名" class="headerlink" title="环绕别名"></a>环绕别名</h4><p>我们可以通过为A方法设置一个别名B，然后重新定义A方法，插入新添加的功能，最后在A中调用B方法(别名了的原A方法，利用了上面说到的“指向未被修改时的代码”的特性)。<br>但是这种方法有猴子补丁的问题：所有地方的这个方法都被改变了，但是也许我们只需要在某些地方包装这个方法。</p>
<h3 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h3><p>refinements 提供一种方法让类的修改只影响某个作用域，而可以避免猴子补丁那样影响全局的问题。看下面的代码，我添加一个camelize方法到String类中，但它只能被Foo使用。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Camelize</span></span></div><div class="line">  refine String <span class="keyword">do</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">camelize</span></span></div><div class="line">      dup.gsub(<span class="regexp">/_([a-z])/</span>) &#123; $1.upcase &#125;</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></div><div class="line">  using Camelize</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">camelize_string</span><span class="params">(str)</span></span></div><div class="line">    str.camelize</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Foo.new.camelize_string(<span class="string">'blah_blah_blah'</span>)	<span class="comment"># =&gt; "blahBlahBlah"</span></div><div class="line"><span class="string">'blah_blah_blah'</span>.camelize	<span class="comment"># =&gt; NoMethodError</span></div></pre></td></tr></table></figure>
<p>当Foo中声明了 refinement 时，我们可以看出它可以使用直接camelize了，但在Foo外却无法使用它。</p>
<p>在refine中使用super可以向方法中包装额外的功能。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">StringRefinement</span></span></div><div class="line">	refine String <span class="keyword">do</span></div><div class="line">		<span class="function"><span class="keyword">def</span> <span class="title">length</span></span></div><div class="line">			<span class="keyword">super</span> &gt; <span class="number">5</span> ? <span class="string">'long'</span> : <span class="string">'short'</span></div><div class="line">		<span class="keyword">end</span></div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">using StringRefinement</div><div class="line"></div><div class="line"><span class="string">"War and Peace"</span>.length			<span class="comment"># =&gt; "long"</span></div></pre></td></tr></table></figure>
<p>这样可以确保只在需要这个特性的时候才用到，不会在任何地方都曲解String#length的意思导致混乱。</p>
<h3 id="Module-prepend包装"><a href="#Module-prepend包装" class="headerlink" title="Module#prepend包装"></a>Module#prepend包装</h3><p>Module#prepend的作用和include类似，只是它把包含的模块插在祖先链的下方，这样的话寻找方法时会先找到被包含的模块中的方法，同时可以通过super调用该类中的原始方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ExplicitString</span></span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">length</span></span></div><div class="line">		<span class="keyword">super</span> &gt; <span class="number">5</span> ? <span class="string">'long'</span> : <span class="string">'short'</span></div><div class="line">	<span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">String class_eval <span class="keyword">do</span></div><div class="line">	prepend ExplicitString</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="string">"War and Peace"</span>.length 		<span class="comment"># =&gt; 'long'</span></div></pre></td></tr></table></figure>
<p>这一种方法最为清晰，既避免了猴子补丁，也不用考虑细化的问题。细化会导致很多问题，具体可以看<a href="http://yafeilee.me/blogs/50bf724f1563883ed4000003" target="_blank" rel="external">这篇文章</a>，大意是原来的方法调用可以做到缓存来静态查找，但是现在refine让方法查找必须动态。更糟糕的是，任何一个块被调用的时候都有可能被refine了，这是很恐怖的。</p>
<p>这章就到这里吧~~</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-10-28</span><i class="fa fa-tag"></i><a href="/tags/Ruby/" title="Ruby" class="tag">Ruby </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2015/10/28/Ruby元编程-Week-4/,沈小黑的菜园,Ruby元编程 星期四,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/11/02/Ruby元编程-Week-5/" title="Ruby元编程 星期五" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/10/26/Ruby元编程-Week-3/" title="Ruby元编程 星期三" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>