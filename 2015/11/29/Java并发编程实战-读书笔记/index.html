<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Java并发编程实战 读书笔记 · 沈小黑的菜园</title><meta name="description" content="Java并发编程实战——一本近300页的薄书，但是却延宕了相当长一段时间。中间上公开课，转职……注意力完全不在这本书上，到现在也只看了一半。想来应该做个笔记，就先把之前看的一半笔记写上，一并算是复习了。

对象的共享可见性所谓可见性就是变量在被访问的时候一定是最新的值。下面的程序展示了一种不满足可见"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java并发编程实战 读书笔记</a></h3></div><div class="post-content"><p>Java并发编程实战——一本近300页的薄书，但是却延宕了相当长一段时间。中间上公开课，转职……注意力完全不在这本书上，到现在也只看了一半。想来应该做个笔记，就先把之前看的一半笔记写上，一并算是复习了。</p>
<a id="more"></a>
<h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>所谓可见性就是变量在被访问的时候一定是最新的值。下面的程序展示了一种不满足可见性的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number=<span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!ready)</div><div class="line">                Thread.yield();</div><div class="line">            System.out.println(number);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">new</span> ReaderThread().start();</div><div class="line"></div><div class="line">        ready = <span class="keyword">true</span>;</div><div class="line">        number = <span class="number">42</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个简单的程序，可能会死循环或输出0，因为编译器、处理器等会对操作的顺序进行调整，称为“重排序”，因为在这里主线程和readerThread没有共享数据。</p>
<h3 id="最低安全性与64位操作"><a href="#最低安全性与64位操作" class="headerlink" title="最低安全性与64位操作"></a>最低安全性与64位操作</h3><p>虽然在没有同步的情况下会读取到失效值，但至少是某个线程设置的值而不是随机数，这被称为最低安全性。上面的NoVisibility就满足最低安全性，number只可能是0或者42。但是并不是所有情况都能满足最低安全性。当操作64位数的时候，比如非volatile的long和double，就不满足最低安全性，因为JVM允许将它们分为两个32位操作，而这两个32位操作如果在不同线程中执行，那么很可能只读到一半的32位内容。</p>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。加锁机制确保了本线程的写入值在其他线程是可见的，而不是让其他线程读到了失效值。</p>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>加锁机制能够保证变量的可见性，但是开销却难免比较大，而volatile是稍弱的同步机制，确保将变量的更新操作通知到其他线程。</p>
<p>可见性问题的本质就是编译器为了优化而进行指令的重排序和寄存器缓存，当声明为volatile之后，编译器与运行时不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存到寄存器上，所以读取volatile类型的变量时总会返回最新写入的值。</p>
<h3 id="volatile和加锁在操作原子性上的差异"><a href="#volatile和加锁在操作原子性上的差异" class="headerlink" title="volatile和加锁在操作原子性上的差异"></a>volatile和加锁在操作原子性上的差异</h3><p>访问volatile变量不会执行加锁操作，所以不会使线程阻塞，也就不能保证原子性。而加锁操作既可以保证可见性又可以保证原子性。因此，我写了一小段自增1000次到10000的多线程代码，比较volatile和内置锁不同的表现。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><img title="volatile原子性表现" alt="volatile原子性表现" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/volatile原子性表现.png">
<p>最后看到的值没有到达10000(出现频率大概在10%)，说明没有做到原子写(写操作不能被影响)。</p>
<h4 id="内置锁-synchronized"><a href="#内置锁-synchronized" class="headerlink" title="内置锁(synchronized)"></a>内置锁(synchronized)</h4><img title="加锁原子性表现" alt="加锁原子性表现" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/加锁原子性表现.png">
<p>最后看到的值都到达了10000，说明写操作是原子的</p>
<h3 id="使用volatile的条件"><a href="#使用volatile的条件" class="headerlink" title="使用volatile的条件"></a>使用volatile的条件</h3><p>根据volatile只保证可见性而不保证原子性的特征，可以在以下的情况下替代加锁操作，毕竟加锁操作的开销很大。</p>
<ol>
<li>写入值不依赖值的当前状态，或者确保只有单个线程更新变量的值</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问时不需要加锁</li>
</ol>
<h2 id="线程封闭的方法"><a href="#线程封闭的方法" class="headerlink" title="线程封闭的方法"></a>线程封闭的方法</h2><p>线程封闭是指仅在单个线程中访问数据的技巧，这样可以避免共享数据而需要的同步。</p>
<h3 id="Ad-hoc线程封闭"><a href="#Ad-hoc线程封闭" class="headerlink" title="Ad-hoc线程封闭"></a>Ad-hoc线程封闭</h3><p>自己专门设计一个程序来维护线程的封闭性，Ad hoc是拉丁文常用短语中的一个短语。这个短语的意思是“特设的、特定目的的（地）、即席的、临时的、将就的、专案的”。这个短语通常用来形容一些特殊的、不能用于其它方面的的，为一个特定的问题、任务而专门设定的解决方案。比如开发一个只有单个线程修改volatile的程序。</p>
<h3 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h3><p>栈封闭将变量封闭在方法体中，只能通过局部变量才能访问到对象。</p>
<p>对于基本类型，由于没有引用，无论如何都不会破坏栈封闭性。对于对象，要注意不要将需要封闭的对象逸出，被外部线程访问到。这样的话，对象位于执行线程的栈中，其他线程无法访问这个栈。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>ThreadLocal是更规范的一种做法，它能够使线程中的某个值与保存值的对象关联起来。</p>
<p>ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的备份。通常ThreadLocal用于防止对可变的单实例变量或全局变量进行共享。当第一次使用get时，ThreadLocal通过initalValue获得初始值</p>
<h3 id="ThreadLocal与实例变量的区别"><a href="#ThreadLocal与实例变量的区别" class="headerlink" title="ThreadLocal与实例变量的区别"></a>ThreadLocal与实例变量的区别</h3><p>实例变量为对象实例私有，在java虚拟机的堆中分配，如果在系统中只存在一个此对象的实例，在多线程环境下，就像静态变量那样，被某个线程修改后，其他线程对修改均可见，故线程非安全；如果每个线程执行都是在不同的对象中，那对象与对象之间的实例变量的修改将互不影响，所以线程安全。 </p>
<p>下例中，使用ThreadLocal和实例变量的String分别创建20个线程，每个线程报告自己所看到的编号。这里使用实例变量的线程就会产生看到其他线程变量的情况，而ThreadLocal就不会产生这样的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWithOutLocal</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String strHolder = <span class="keyword">new</span> String();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadWithOutLocal</span><span class="params">(<span class="keyword">int</span> _i)</span></span>&#123;</div><div class="line">        value = _i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        strHolder=<span class="string">"value "</span>+value;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</div><div class="line">           System.out.println(<span class="string">"thread "</span>+value+<span class="string">" saw "</span>+strHolder);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    ThreadWithOutLocal[] list = <span class="keyword">new</span> ThreadWithOutLocal[<span class="number">20</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">        list[i] = <span class="keyword">new</span> ThreadWithOutLocal(i);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">        list[i].start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的代码输出就可能会产生下图的情况：</p>
<img title="静态实例变量多线程的访问混乱" alt="静态实例变量多线程的访问混乱" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/静态实例变量多线程的访问混乱.png">
<p>这里是因为static在所有类的实例中都可以访问，但除了static，就算是私有变量也有可能会因为使用同一个对象创建多个线程而产生问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Runnable accumelatora = <span class="keyword">new</span> Accumulatort();  </div><div class="line">        Thread threada = <span class="keyword">new</span> Thread(accumelatora, <span class="string">"ThreadA"</span>);  </div><div class="line">        Thread threadb = <span class="keyword">new</span> Thread(accumelatora, <span class="string">"ThreadB"</span>);  </div><div class="line">        threada.start();  </div><div class="line">        threadb.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumulatort</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="comment">// 实例变量  </span></div><div class="line">    <span class="keyword">int</span> locals = <span class="number">0</span>;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;  </div><div class="line">            locals += <span class="number">1</span>;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            &#125;  </div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + locals);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的locals变量会产生大于10的结果，这可能就不是开发者所期望的效果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWithLocal</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; strHolder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadWithLocal</span><span class="params">(<span class="keyword">int</span> _i)</span></span>&#123;</div><div class="line">        value = _i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        strHolder.set(<span class="string">"value "</span>+value);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</div><div class="line">            System.out.println(<span class="string">"thread "</span>+value+<span class="string">" saw "</span>+strHolder.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    ThreadWithLocal[] list = <span class="keyword">new</span> ThreadWithLocal[<span class="number">20</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">        list[i] = <span class="keyword">new</span> ThreadWithLocal(i);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">        list[i].start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal以线程为单位，而不是以实例为单位，所以就杜绝了产生上面两种问题的可能性：</p>
<img title="ThreadLocal多线程访问正常" alt="ThreadLocal多线程访问正常" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/ThreadLocal多线程访问正常.png">
<h1 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h1><h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><p>同步容器类包括Vector和Hashtable，它们会将所有对容器状态访问的操作都串行化，所以会严重降低并发性。在迭代的时候，也会对容器进行加锁，如果不想要受到这个影响的话，可以克隆容器并且在副本上进行迭代。</p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>并发容器针对多线程并发访问设计，比如ConcurrentHashMap，CopyOnWriteArrayList等。同步容器类在执行每个操作的时候都会持有一个锁，而并发容器使用粒度更细的加锁机制——分段锁。所以允许更多线程同时进行操作。</p>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><h3 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h3><p>闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。CountDownLatch是一种灵活的闭锁实现，await会等待计数到达零。</p>
<blockquote>
<p>CountDownLatch是一次性对象， 只有CountDown而没有CountUp方法</p>
</blockquote>
<p>如下的代码中，startGate用于协调所有的线程同时开始，endGate用于标记所有的线程同时结束。只有在startGate降到0，线程才会开始，在endGate降到0，才会结束并得到endTime。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        TestCountDownLatch test = <span class="keyword">new</span> TestCountDownLatch();</div><div class="line">        test.test(<span class="number">100</span>,<span class="keyword">new</span> MyTask());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;++i)&#123;</div><div class="line">                ++j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> nThread, <span class="keyword">final</span> Runnable task)</span></span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThread);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nThread;++i)&#123;</div><div class="line">            Thread th = <span class="keyword">new</span> Thread() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        startGate.await();</div><div class="line"></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            task.run();</div><div class="line">                        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                            endGate.countDown();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            th.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</div><div class="line">        startGate.countDown();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            endGate.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">        System.out.println(<span class="string">"the time is "</span>+(endTime-startTime));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask也可以用作闭锁。表示的计算是通过Callable来实现的，表示一种抽象的可生成结果的Runnable，处于等待、运行中和运行完成这三种状态中的一种。（运行完成也可能是运行失败或被中断等）</p>
<p>Future.get的行为是阻塞的，如果任务没有完成会一直阻塞。确保了结果的传递是安全发布的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFutureTask</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//    package the FutureTask with callable task</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">int</span> pre=<span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> after=<span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;++i)&#123;</div><div class="line">                result = after+pre;</div><div class="line">                pre = after;</div><div class="line">                after = result;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"calc result is "</span>+future.get());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        TestFutureTask testFutureTask = <span class="keyword">new</span> TestFutureTask();</div><div class="line">        testFutureTask.test();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p>信号量管理着一组虚拟的许可，release是释放一个信号量，acquire是申请一个信号量。如果没有获得许可，acquire将阻塞直到有许可。</p>
<p>Semaphore并不受限于构造函数中的许可数量。当release的时候，总会新增一个许可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore sem = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.i = i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                sem.acquire();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(<span class="string">"current i: "</span> + i + <span class="string">"   start time: "</span> + System.nanoTime());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(<span class="string">"current i:"</span>+i+<span class="string">"   release time:"</span>+System.nanoTime());</div><div class="line">            sem.release();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTest</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</div><div class="line">            myRunnable.setI(i);</div><div class="line"></div><div class="line">            Thread th = <span class="keyword">new</span> Thread(myRunnable);</div><div class="line"></div><div class="line">            th.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TestSemaphore test = <span class="keyword">new</span> TestSemaphore();</div><div class="line">        sem.release();          <span class="comment">//additional release can make the semaphore to be more than 5</span></div><div class="line">        test.startTest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的代码在main函数中额外release了一下，则可以看到前6个线程都直接申请到了信号量，而后四个则只能等其他线程释放信号量之后才得到信号量</p>
<img title="信号量实验结果" alt="信号量实验结果" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/信号量实验结果.png">
<h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>栅栏类似于闭锁，能阻塞一组线程直到某个事件发生。区别在于：闭锁的准许信号可以来自外部，也可以来自其他线程，只要能让CountDownLntch的信号到0即可，设置CountDownLntch的地方不一定在await；而栅栏是所有线程之间互相等待，直到所有线程都到达某一个栅栏。闭锁用于等待事件，而栅栏用于等待其他线程。</p>
<p>闭锁一旦到达终止状态，就不能被重置。而栅栏在所有线程都到达后，所有线程都会被放行，而栅栏将会被重置。如果超时或被中断，会抛出BrokenBarrierException。成功地通过栅栏之后，await将会为每个线程返回唯一的到达索引号。</p>
<p>当一个计算的下一步需要其他并行的计算结果的状态时，经常就需要栅栏。</p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier允许将一个Runnable传递给构造函数，当成功通过栅栏时会在一个子任务线程中自动执行这个Runnable。CyclicBarrier可以使一定数量的参与方反复地汇集在栅栏处，这在并行迭代算法中非常有用——通常将一个问题拆分成一系列相互独立的子问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] currentValue = <span class="keyword">new</span> <span class="keyword">int</span>[count*<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(count, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//第一个到达的线程会运行这一行代码</span></div><div class="line">            System.out.println(<span class="string">"get the barrier!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> currentI;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> currentBase;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> nextBase;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.currentI = i;</div><div class="line">            currentBase = currentI;</div><div class="line">            nextBase = currentI+count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                currentValue[currentBase] = <span class="number">0</span>;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> multi = currentBase/count;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</div><div class="line">                    currentValue[currentBase] += currentValue[(<span class="number">1</span>-multi) * count + i];</div><div class="line"></div><div class="line">                <span class="keyword">int</span> tmp = currentBase;</div><div class="line">                currentBase = nextBase;</div><div class="line">                nextBase = tmp;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> index = barrier.await();</div><div class="line">        </div><div class="line">                System.out.println(index);</div><div class="line"></div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count*<span class="number">2</span>;++i)&#123;</div><div class="line">            currentValue[i] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;++i) &#123;</div><div class="line">            MyTask myTask = <span class="keyword">new</span> MyTask(i);</div><div class="line">            Thread th = <span class="keyword">new</span> Thread(myTask);</div><div class="line">            th.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<img title="CyclicBarrier实验结果" alt="CyclicBarrier实验结果" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/CyclicBarrier实验结果.png">
<h3 id="构建高性能可伸缩结果缓存的实践"><a href="#构建高性能可伸缩结果缓存的实践" class="headerlink" title="构建高性能可伸缩结果缓存的实践"></a>构建高性能可伸缩结果缓存的实践</h3><p>假设条件：有一个非常耗时的计算操作，希望将计算结果存入一个Map来避免重复计算</p>
<p>使用ConcurrentHashMap依然可能会导致重复计算：如果发现某一个key没有被计算过，但其实另一个线程正在进行耗时的计算，计算后就会把这个键put进去，那依然会进行重复计算。</p>
<h4 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h4><p>使用FurureTask来进行计算，存储Map内容为ConcurrentHashMap<key,future<result>&gt;，这样，当一个线程正在计算result时，HashMap中已经存有Key,即使没有计算完成也会阻塞地进行读取。</key,future<result></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCachedPool</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> ConcurrentHashMap&lt;Integer,Future&lt;Integer&gt;&gt; pool = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, Future&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getResult</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">        Future&lt;Integer&gt; result = pool.get(key);</div><div class="line">        <span class="keyword">if</span> (result==<span class="keyword">null</span>)&#123;</div><div class="line">            Callable&lt;Integer&gt; calcuTask = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">return</span> ComplexCalculation.complexCalculation(key);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            FutureTask&lt;Integer&gt; calcResult = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(calcuTask);</div><div class="line">            result = calcResult;</div><div class="line">            pool.put(key,calcResult);</div><div class="line">            calcResult.run();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> result.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="存留问题"><a href="#存留问题" class="headerlink" title="存留问题"></a>存留问题</h4><p>依然可能导致进行重复计算：判断是否存在此key和put一个key之间的空隙，依然可能导致脏读而重复计算: </p>
<img title="构造高性能缓存_检查与put之间的间隙" alt="构造高性能缓存_检查与put之间的间隙" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/构造高性能缓存_检查与put之间的间隙.png">
<p>执行结果中些许的重复计算：</p>
<img title="构造高性能缓存_执行结果中些许的重复计算" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/构造高性能缓存_执行结果中些许的重复计算.png">
<h4 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h4><p>使用putIfAbsent来解决可能重复put的问题，如果该方法返回null，说明之前没有已经插入的内容，则可以开始计算。</p>
<p>优化后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterFutureCachedPool</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> ConcurrentHashMap&lt;Integer,Future&lt;Integer&gt;&gt; pool = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, Future&lt;Integer&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getResult</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">        Future&lt;Integer&gt; result = pool.get(key);</div><div class="line">        <span class="keyword">if</span> (result==<span class="keyword">null</span>)&#123;</div><div class="line">            Callable&lt;Integer&gt; calcuTask = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">return</span> ComplexCalculation.complexCalculation(key);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            FutureTask&lt;Integer&gt; calcResult = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(calcuTask);</div><div class="line"></div><div class="line"><span class="comment">//            only calculates when there is no conflict</span></div><div class="line">            result = pool.putIfAbsent(key,calcResult);</div><div class="line">            <span class="keyword">if</span> (result==<span class="keyword">null</span>) &#123;</div><div class="line">                result = calcResult;</div><div class="line">                calcResult.run();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> result.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算情况如下，可以发现没有如上面那样的重复计算了：<br><img title="构造高性能缓存_没有重复计算" src="http://7xltls.com1.z0.glb.clouddn.com/images/notes/java并发编程实战/构造高性能缓存_没有重复计算.png"></p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>Future可能会导致缓存污染的问题：如果Future计算失败了或超时了，在Map中依然存有此Future，所以需要在超时或失败之后将此Future从Map中移除</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-11-29</span><i class="fa fa-tag"></i><a href="/tags/读书笔记/" title="读书笔记" class="tag">读书笔记 </a><a href="/tags/Java/" title="Java" class="tag">Java </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2015/11/29/Java并发编程实战-读书笔记/,沈小黑的菜园,Java并发编程实战 读书笔记,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/12/29/Hadoop笔记/" title="HDFS起步笔记" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/11/02/Ruby元编程-Week-5/" title="Ruby元编程 星期五" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>