<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Redis设计与实现——SDS实现与代码解读 · 沈小黑的菜园</title><meta name="description" content="SDS原理总体概述：是Redis中可变字符串的数据结构，所有可变的字符串都使用此数据结构。除了被用作字符串，还被用作缓冲区。

数据结构len标记已占用长度，free标记剩余长度，buf[]是char数组。
‘\0’不算在长度中，遵循’\0’结尾的好处是可以重用C函数库的函数。如printf等。
S"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis设计与实现——SDS实现与代码解读</a></h3></div><div class="post-content"><h1 id="SDS原理"><a href="#SDS原理" class="headerlink" title="SDS原理"></a>SDS原理</h1><p>总体概述：是Redis中可变字符串的数据结构，所有可变的字符串都使用此数据结构。除了被用作字符串，还被用作缓冲区。</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>len标记已占用长度，free标记剩余长度，buf[]是char数组。</p>
<p>‘\0’不算在长度中，遵循’\0’结尾的好处是可以重用C函数库的函数。如printf等。</p>
<h2 id="SDS记录长度的好处"><a href="#SDS记录长度的好处" class="headerlink" title="SDS记录长度的好处"></a>SDS记录长度的好处</h2><ol>
<li>SDS获得字符长度的时间是O(1)</li>
<li>SDS可以防止字符串溢出，意外修改其它区域的数据。</li>
<li>使用len记录长度，不用依靠’\0’判断结尾，所以可以保存二进制数据</li>
</ol>
<h2 id="SDS内存分配策略"><a href="#SDS内存分配策略" class="headerlink" title="SDS内存分配策略"></a>SDS内存分配策略</h2><p>对SDS中的字符串进行修改导致字符串长度改变的时候，需要进行内存重分配。</p>
<p>由于内存分配耗时，很可能成为高频修改时的一个性能瓶颈。所以会进行空间预分配和惰性空间释放。</p>
<h3 id="空间预分配公式"><a href="#空间预分配公式" class="headerlink" title="空间预分配公式"></a>空间预分配公式</h3><ul>
<li>如果len在修改后小于1MB，分配和len一样多的free空间。</li>
<li>如果大于1MB，分配1MB的未使用空间。</li>
</ul>
<h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>在长度缩短的时候SDS不会主动释放free的空间，在有必要的时候才真正释放。</p>
<h2 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h2><p>C字符串处理二进制数据可能会因为’\0’的原因提前结束。SDS以处理二进制的方式来处理buf数组的数据，不会作任何过滤。</p>
<p>所以SDS本质上是保存一系列二进制数据，因此SDS也能作为缓冲区的实现。保存字符只是通过保存二进制实现的功能。</p>
<h1 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h1><p>Redis中SDS的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 根据给定的初始化字符串 init 和字符串长度 initlen</div><div class="line"> * 创建一个新的 sds</div><div class="line"> *</div><div class="line"> * 参数</div><div class="line"> *  init ：初始化字符串指针</div><div class="line"> *  initlen ：初始化字符串的长度</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</div><div class="line"> *        创建失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Create a new sds string with the content specified by the 'init' pointer</span></div><div class="line"> * and 'initlen'.</div><div class="line"> * If NULL is used for 'init' the string is initialized with zero bytes.</div><div class="line"> *</div><div class="line"> * The string is always null-termined (all the sds strings are, always) so</div><div class="line"> * even if you create an sds string with:</div><div class="line"> *</div><div class="line"> * mystring = sdsnewlen("abc",3");</div><div class="line"> *</div><div class="line"> * You can print the string with printf() as there is an implicit \0 at the</div><div class="line"> * end of the string. However the string is binary safe and can contain</div><div class="line"> * \0 characters in the middle, as the length is stored in the sds header. */</div><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> sdshdr *sh;</div><div class="line"></div><div class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="keyword">if</span> (init) &#123;</div><div class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></div><div class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></div><div class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 内存分配失败，返回</span></div><div class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 设置初始化长度</span></div><div class="line">    sh-&gt;len = initlen;</div><div class="line">    <span class="comment">// 新 sds 不预留任何空间</span></div><div class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</div><div class="line">    <span class="comment">// 以 \0 结尾</span></div><div class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他诸如创建空SDS都是使用这个接口进行的封装，而其中sdsMakeRoomFor方法则体现了Redis对free空间分配的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/* 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></div><div class="line"> * buf 至少会有 addlen + 1 长度的空余空间</div><div class="line"> * （额外的 1 字节是为 \0 准备的）</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：扩展成功返回扩展后的 sds</div><div class="line"> *        扩展失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> sdshdr *sh, *newsh;</div><div class="line"></div><div class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></div><div class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</div><div class="line"></div><div class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</div><div class="line"></div><div class="line">    <span class="comment">// s 最少需要的长度</span></div><div class="line">    newlen = (len+addlen);</div><div class="line"></div><div class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></div><div class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></div><div class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></div><div class="line">        newlen *= <span class="number">2</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 内存不足，分配失败，返回</span></div><div class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 更新 sds 的空余长度</span></div><div class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line"></div><div class="line">    <span class="comment">// 返回 sds</span></div><div class="line">    <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-05-30</span><i class="fa fa-tag"></i><a href="/tags/Redis/" title="Redis" class="tag">Redis </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2016/05/30/Redis设计与实现——SDS实现与代码解读/,沈小黑的菜园,Redis设计与实现——SDS实现与代码解读,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/05/30/Redis设计与实现——SDS哈希表/" title="Redis设计与实现——SDS哈希表" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/03/18/再探排序/" title="再探排序" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>