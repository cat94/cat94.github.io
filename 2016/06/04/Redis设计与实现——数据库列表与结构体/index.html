<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="点滴收获" />



  <meta name="keywords" content="Redis," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="数据库数据库列表redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。
一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis设计与实现——数据库列表与结构体">
<meta property="og:url" content="http://www.shenjianan.net/2016/06/04/Redis设计与实现——数据库列表与结构体/index.html">
<meta property="og:site_name" content="沈小黑的菜园">
<meta property="og:description" content="数据库数据库列表redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。
一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。">
<meta property="og:updated_time" content="2016-07-23T06:27:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis设计与实现——数据库列表与结构体">
<meta name="twitter:description" content="数据库数据库列表redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。
一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Redis设计与实现——数据库列表与结构体 | 沈小黑的菜园 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">沈小黑的菜园</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '2G2hzrM2qW7Y8zUsJDDr','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Redis设计与实现——数据库列表与结构体
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-06-04T14:38:36+08:00" content="2016-06-04">
            2016-06-04
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/06/04/Redis设计与实现——数据库列表与结构体/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/04/Redis设计与实现——数据库列表与结构体/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库列表"><a href="#数据库列表" class="headerlink" title="数据库列表"></a>数据库列表</h2><p>redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。</p>
<p>一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line"></div><div class="line">	<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    </div><div class="line">    <span class="comment">//...</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> dbnum;                      <span class="comment">/* Total number of configured DBs */</span></div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>redis.h/redisClient在切换数据库的时候，就会将redisClient中的db指针指向具体的数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	</div><div class="line">	<span class="comment">// 当前正在使用的数据库</span></div><div class="line">	redisDb *db;</div><div class="line">	</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125; redisClient;</div></pre></td></tr></table></figure>
<h2 id="redisDb结构"><a href="#redisDb结构" class="headerlink" title="redisDb结构"></a>redisDb结构</h2><p>redis.h/redisDb表示一个数据库，其中包含有当前数据库所有的键值对、键的过期时间字典、阻塞中的键、可以解除阻塞的键、正被监视的键和数据库号码等信息。相对redisServer和redisClient来说是很简单的数据结构，主要就是服务于键值处理。其中的键值都只是指针，真正的键值对象都在别处分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></div><div class="line"> * by integers from 0 (the default database) up to the max configured</div><div class="line"> * database. The database number is the 'id' field in the structure. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></div><div class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></div><div class="line"></div><div class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></div><div class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正处于阻塞状态的键</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line"></div><div class="line">    <span class="comment">// 可以解除阻塞的键</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库号码</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></div><div class="line"></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>增删改查实际上就是对dict和dict指向的键值进行的操作，在对数据库进行读写的时候，服务器还会更新命中次数、不命中次数和LRU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer&#123;</div><div class="line"></div><div class="line">	<span class="comment">//...</span></div><div class="line">	</div><div class="line">    <span class="comment">// 最近一次使用时钟</span></div><div class="line">    <span class="keyword">unsigned</span> lruclock:REDIS_LRU_BITS; <span class="comment">/* Clock for LRU eviction */</span></div><div class="line">	</div><div class="line">	<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="comment">// 成功查找键的次数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_hits;   <span class="comment">/* Number of successful lookups of keys */</span></div><div class="line"></div><div class="line">    <span class="comment">// 查找键失败的次数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_misses; <span class="comment">/* Number of failed lookups of keys */</span></div><div class="line">    </div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在读写之前，服务器会先检查是否过期，如果过期则需要删除这个键，下面是getCommand底层依赖的取值方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 为执行读取操作而取出键 key 在数据库 db 中的值。</div><div class="line"> *</div><div class="line"> * 并根据是否成功找到值，更新服务器的命中/不命中信息。</div><div class="line"> *</div><div class="line"> * 找到时返回值对象，没找到返回 NULL 。</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    <span class="comment">// 检查 key 释放已经过期</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 从数据库中取出键的值</span></div><div class="line">    val = lookupKey(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 更新命中/不命中信息</span></div><div class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        server.stat_keyspace_hits++;</div><div class="line"></div><div class="line">    <span class="comment">// 返回值</span></div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于WATCH键，被WATCH命令监视的键都会被标记为dirty，每修改一个键之后，都会对dirty键计数器的值增1，这个计数器会出发服务器的持久化以及复制操作。</p>
<h2 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h2><p>Redis使用惰性删除和定期删除两种策略。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>db.c中的方法都是数据库级别的操作，比如过期时间、清空键、数据库大小、覆写等。</p>
<p>惰性删除的函数实现是db.c/expireIfNeeded。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 检查 key 是否已经过期，如果是的话，将它从数据库中删除。</div><div class="line"> *</div><div class="line"> * 返回 0 表示键没有过期时间，或者键未过期。</div><div class="line"> *</div><div class="line"> * 返回 1 表示键已经因为过期而被删除了。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 取出键的过期时间</span></div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line"></div><div class="line">    <span class="comment">// 没有过期时间说明永不过期</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></div><div class="line">    <span class="comment">// 如果服务器正在进行载入，那么不进行任何过期检查</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></div><div class="line">     * blocked to when the Lua script started. This way a key can expire</div><div class="line">     * only the first time it is accessed and not in the middle of the</div><div class="line">     * script execution, making propagation to slaves / AOF consistent.</div><div class="line">     * See issue #1525 on Github for more information. */</div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line"></div><div class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></div><div class="line">     * the slave key expiration is controlled by the master that will</div><div class="line">     * send us synthesized DEL operations for expired keys.</div><div class="line">     *</div><div class="line">     * Still we try to return the right information to the caller, </div><div class="line">     * that is, 0 if we think the key should be still valid, 1 if</div><div class="line">     * we think the key is expired at this time. */</div><div class="line">    <span class="comment">// 当服务器运行在 replication 模式时</span></div><div class="line">    <span class="comment">// 附属节点并不主动删除 key</span></div><div class="line">    <span class="comment">// 它只返回一个逻辑上正确的返回值</span></div><div class="line">    <span class="comment">// 真正的删除操作要等待主节点发来删除命令时才执行</span></div><div class="line">    <span class="comment">// 从而保证数据的同步</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line"></div><div class="line">    <span class="comment">// 运行到这里，表示键带有过期时间，并且服务器为主节点</span></div><div class="line"></div><div class="line">    <span class="comment">/* Return when this key has not expired */</span></div><div class="line">    <span class="comment">// 如果未过期，返回 0</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Delete the key */</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line"></div><div class="line">    <span class="comment">// 向 AOF 文件和附属节点传播过期信息</span></div><div class="line">    propagateExpire(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 发送事件通知</span></div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line"></div><div class="line">    <span class="comment">// 将过期键从数据库中删除</span></div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单单使用惰性删除会导致过期但是不再被访问的键占用大量空间，因此还需要使用定期删除来周期性地删除过期键。定期删除的函数是redis.c/activeExpireCycle，下面是被它调用的activeExpireCycleTryExpire:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ======================= Cron: called every 100 ms ======================== */</span></div><div class="line"></div><div class="line"><span class="comment">/* Helper function for the activeExpireCycle() function.</span></div><div class="line"> * This function will try to expire the key that is stored in the hash table</div><div class="line"> * entry 'de' of the 'expires' hash table of a Redis database.</div><div class="line"> *</div><div class="line"> * activeExpireCycle() 函数使用的检查键是否过期的辅佐函数。</div><div class="line"> *</div><div class="line"> * If the key is found to be expired, it is removed from the database and</div><div class="line"> * 1 is returned. Otherwise no operation is performed and 0 is returned.</div><div class="line"> *</div><div class="line"> * 如果 de 中的键已经过期，那么移除它，并返回 1 ，否则不做动作，并返回 0 。</div><div class="line"> *</div><div class="line"> * When a key is expired, server.stat_expiredkeys is incremented.</div><div class="line"> *</div><div class="line"> * The parameter 'now' is the current time in milliseconds as is passed</div><div class="line"> * to the function to avoid too many gettimeofday() syscalls.</div><div class="line"> *</div><div class="line"> * 参数 now 是毫秒格式的当前时间</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">activeExpireCycleTryExpire</span><span class="params">(redisDb *db, dictEntry *de, <span class="keyword">long</span> <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取键的过期时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = dictGetSignedIntegerVal(de);</div><div class="line">    <span class="keyword">if</span> (now &gt; t) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 键已过期</span></div><div class="line"></div><div class="line">        sds key = dictGetKey(de);</div><div class="line">        robj *keyobj = createStringObject(key,sdslen(key));</div><div class="line"></div><div class="line">        <span class="comment">// 传播过期命令</span></div><div class="line">        propagateExpire(db,keyobj);</div><div class="line">        <span class="comment">// 从数据库中删除该键</span></div><div class="line">        dbDelete(db,keyobj);</div><div class="line">        <span class="comment">// 发送事件</span></div><div class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">            <span class="string">"expired"</span>,keyobj,db-&gt;id);</div><div class="line">        decrRefCount(keyobj);</div><div class="line">        <span class="comment">// 更新计数器</span></div><div class="line">        server.stat_expiredkeys++;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 键未过期</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的dbDelete会删除这个数据库里面的过期时间、键值对，但是decrRefCount不一定会释放这个值的内存，因为可能有别的值引用了这个对象。只有当refCount降到0的时候，才会释放它的内存。下面是db.c/decrRefCount的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB </span></div><div class="line"> *</div><div class="line"> * 从数据库中删除给定的键，键的值，以及键的过期时间。</div><div class="line"> *</div><div class="line"> * 删除成功返回 1 ，因为键不存在而导致删除失败时，返回 0 。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">// 删除键的过期时间</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 删除键值对</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="comment">// 如果开启了集群模式，那么从槽中删除给定的键</span></div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 键不存在</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是定期删除过期键的函数activeExpireCycle，它不会强求一次性将所有的过期键删除，而是在一个规定的时间内删除一部分的过期时间，并且在一段时间后再启动。在前期的启动模式判断、变量初始化之后，计算轮到清理的数据库，并且将数据库号加一，也就是说就算数据库0没有在当前时限内处理完毕，下次也依旧会处理数据库1，相当于时间片轮转的清理方式。</p>
<p>在对数据库进行清理之前，代码会先检查带有过期时间的键值对数量，记录当前时间，如果所有键值对都是永不过期的或者可过期键值对占比小于1%，那就直接跳过这个数据库；如果可过期键数量M超过<strong>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</strong>，还要只检查<strong>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</strong>个键。在这之后，进行M次循环，每次循环随机取一个键，如果已经过期则删除之(调用activeExpireCycleTryExpire)，更新统计数据。每进行16次遍历，就检查是否已经超过时间限制，如果超过则结束此过程。</p>
<p>最后，每次遍历都会进行检查。如果已经删除了带过期时间键数量的25%，则不再进行遍历，转而处理下一个数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Try to expire a few timed out keys. The algorithm used is adaptive and</span></div><div class="line"> * will use few CPU cycles if there are few expiring keys, otherwise</div><div class="line"> * it will get more aggressive to avoid that too much memory is used by</div><div class="line"> * keys that can be removed from the keyspace.</div><div class="line"> *</div><div class="line"> * 函数尝试删除数据库中已经过期的键。</div><div class="line"> * 当带有过期时间的键比较少时，函数运行得比较保守，</div><div class="line"> * 如果带有过期时间的键比较多，那么函数会以更积极的方式来删除过期键，</div><div class="line"> * 从而可能地释放被过期键占用的内存。</div><div class="line"> *</div><div class="line"> * No more than REDIS_DBCRON_DBS_PER_CALL databases are tested at every</div><div class="line"> * iteration.</div><div class="line"> *</div><div class="line"> * 每次循环中被测试的数据库数目不会超过 REDIS_DBCRON_DBS_PER_CALL 。</div><div class="line"> *</div><div class="line"> * This kind of call is used when Redis detects that timelimit_exit is</div><div class="line"> * true, so there is more work to do, and we do it more incrementally from</div><div class="line"> * the beforeSleep() function of the event loop.</div><div class="line"> *</div><div class="line"> * 如果 timelimit_exit 为真，那么说明还有更多删除工作要做，</div><div class="line"> * 那么在 beforeSleep() 函数调用时，程序会再次执行这个函数。</div><div class="line"> *</div><div class="line"> * Expire cycle type:</div><div class="line"> *</div><div class="line"> * 过期循环的类型：</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a</div><div class="line"> * "fast" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION</div><div class="line"> * microseconds, and is not repeated again before the same amount of time.</div><div class="line"> *</div><div class="line"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_FAST ，</div><div class="line"> * 那么函数会以“快速过期”模式执行，</div><div class="line"> * 执行的时间不会长过 EXPIRE_FAST_CYCLE_DURATION 毫秒，</div><div class="line"> * 并且在 EXPIRE_FAST_CYCLE_DURATION 毫秒之内不会再重新执行。</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is</div><div class="line"> * executed, where the time limit is a percentage of the REDIS_HZ period</div><div class="line"> * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. </div><div class="line"> *</div><div class="line"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_SLOW ，</div><div class="line"> * 那么函数会以“正常过期”模式执行，</div><div class="line"> * 函数的执行时限为 REDIS_HS 常量的一个百分比，</div><div class="line"> * 这个百分比由 REDIS_EXPIRELOOKUPS_TIME_PERC 定义。</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></div><div class="line">     * incrementally across calls. */</div><div class="line">    <span class="comment">// 静态变量，用来累积函数连续执行时的数据</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 默认每次处理的数据库数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</div><div class="line">    <span class="comment">// 函数开始的时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit;</div><div class="line"></div><div class="line">    <span class="comment">// 快速模式</span></div><div class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</div><div class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exited</span></div><div class="line">         * for time limt. Also don't repeat a fast cycle for the same period</div><div class="line">         * as the fast cycle total duration itself. */</div><div class="line">        <span class="comment">// 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span></div><div class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 如果距离上次执行未够一定时间，那么不执行处理</span></div><div class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 运行到这里，说明执行快速处理，记录当前时间</span></div><div class="line">        last_fast_cycle = start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</span></div><div class="line">     * two exceptions:</div><div class="line">     *</div><div class="line">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</div><div class="line">     * 除非：</div><div class="line">     *</div><div class="line">     * 1) Don't test more DBs than we have.</div><div class="line">     *    当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</div><div class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</div><div class="line">     * in this iteration, as there is work to do in some DB and we don't want</div><div class="line">     * expired keys to use memory for too much time. </div><div class="line">     *     如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</div><div class="line">     *     这可以避免过多的过期键占用空间</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</div><div class="line">        dbs_per_call = server.dbnum;</div><div class="line"></div><div class="line">    <span class="comment">/* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span></div><div class="line">     * per iteration. Since this function gets called with a frequency of</div><div class="line">     * server.hz times per second, the following is the max amount of</div><div class="line">     * microseconds we can spend in this function. */</div><div class="line">    <span class="comment">// 函数处理的微秒时间上限</span></div><div class="line">    <span class="comment">// ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span></div><div class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</div><div class="line">    timelimit_exit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果是运行在快速模式之下</span></div><div class="line">    <span class="comment">// 那么最多只能运行 FAST_DURATION 微秒 </span></div><div class="line">    <span class="comment">// 默认值为 1000 （微秒）</span></div><div class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</div><div class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</div><div class="line">        <span class="keyword">int</span> expired;</div><div class="line">        <span class="comment">// 指向要处理的数据库</span></div><div class="line">        redisDb *db = server.db+(current_db % server.dbnum);</div><div class="line"></div><div class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></div><div class="line">         * in the current DB we'll restart from the next. This allows to</div><div class="line">         * distribute the time evenly across DBs. */</div><div class="line">        <span class="comment">// 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span></div><div class="line">        <span class="comment">// 那么下次会直接从下个 DB 开始处理</span></div><div class="line">        current_db++;</div><div class="line"></div><div class="line">        <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></div><div class="line">         * of the keys were expired. */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</div><div class="line">            <span class="keyword">int</span> ttl_samples;</div><div class="line"></div><div class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></div><div class="line">            <span class="comment">// 获取数据库中带过期时间的键的数量</span></div><div class="line">            <span class="comment">// 如果该数量为 0 ，直接跳过这个数据库</span></div><div class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</div><div class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取数据库中键值对的数量</span></div><div class="line">            slots = dictSlots(db-&gt;expires);</div><div class="line">            <span class="comment">// 当前时间</span></div><div class="line">            now = mstime();</div><div class="line"></div><div class="line">            <span class="comment">/* When there are less than 1% filled slots getting random</span></div><div class="line">             * keys is expensive, so stop here waiting for better times...</div><div class="line">             * The dictionary will be resized asap. */</div><div class="line">            <span class="comment">// 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span></div><div class="line">            <span class="comment">// 跳过，等待字典收缩程序运行</span></div><div class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></div><div class="line">             * with an expire set, checking for expired ones. </div><div class="line">             *</div><div class="line">             * 样本计数器</div><div class="line">             */</div><div class="line">            <span class="comment">// 已处理过期键计数器</span></div><div class="line">            expired = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 键的总 TTL 计数器</span></div><div class="line">            ttl_sum = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 总共处理的键计数器</span></div><div class="line">            ttl_samples = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span></div><div class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</div><div class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</div><div class="line"></div><div class="line">            <span class="comment">// 开始遍历数据库</span></div><div class="line">            <span class="keyword">while</span> (num--) &#123;</div><div class="line">                dictEntry *de;</div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</div><div class="line"></div><div class="line">                <span class="comment">// 从 expires 中随机取出一个带过期时间的键</span></div><div class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</div><div class="line">                <span class="comment">// 计算 TTL</span></div><div class="line">                ttl = dictGetSignedIntegerVal(de)-now;</div><div class="line">                <span class="comment">// 如果键已经过期，那么删除它，并将 expired 计数器增一</span></div><div class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</div><div class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) ttl = <span class="number">0</span>;</div><div class="line">                <span class="comment">// 累积键的 TTL</span></div><div class="line">                ttl_sum += ttl;</div><div class="line">                <span class="comment">// 累积处理键的个数</span></div><div class="line">                ttl_samples++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></div><div class="line">            <span class="comment">// 为这个数据库更新平均 TTL 统计数据</span></div><div class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</div><div class="line">                <span class="comment">// 计算当前平均值</span></div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span></div><div class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</div><div class="line">                <span class="comment">/* Smooth the value averaging with the previous one. */</span></div><div class="line">                <span class="comment">// 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span></div><div class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/<span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* We can't block forever here even if there are many keys to</span></div><div class="line">             * expire. So after a given amount of milliseconds return to the</div><div class="line">             * caller waiting for the other active expire cycle. */</div><div class="line">            <span class="comment">// 我们不能用太长时间处理过期键，</span></div><div class="line">            <span class="comment">// 所以这个函数执行一定时间之后就要返回</span></div><div class="line"></div><div class="line">            <span class="comment">// 更新遍历次数</span></div><div class="line">            iteration++;</div><div class="line"></div><div class="line">            <span class="comment">// 每遍历 16 次执行一次</span></div><div class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span> &amp;&amp; <span class="comment">/* check once every 16 iterations. */</span></div><div class="line">                (ustime()-start) &gt; timelimit)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 如果遍历次数正好是 16 的倍数</span></div><div class="line">                <span class="comment">// 并且遍历的时间超过了 timelimit</span></div><div class="line">                <span class="comment">// 那么断开 timelimit_exit</span></div><div class="line">                timelimit_exit = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 已经超时了，返回</span></div><div class="line">            <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* We don't repeat the cycle if there are less than 25% of keys</span></div><div class="line">             * found expired in the current DB. */</div><div class="line">            <span class="comment">// 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span></div><div class="line">            <span class="comment">// 那么不再遍历</span></div><div class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF、EDB和复制功能对过期键的处理"><a href="#AOF、EDB和复制功能对过期键的处理" class="headerlink" title="AOF、EDB和复制功能对过期键的处理"></a>AOF、EDB和复制功能对过期键的处理</h2><h3 id="RDB模式"><a href="#RDB模式" class="headerlink" title="RDB模式"></a>RDB模式</h3><p>执行SAVE或者BGSAVE的时候，程序会将未过期的键值保存到新创建的RDB文件中。而当启动Redis的时候，只要开启了RDB功能，那么就会载入RDB文件。</p>
<ul>
<li>如果是主服务器，那么载入时会对保存的键进行检查，只读取未过期的键。</li>
<li>如果是从服务器，那么不会检查是否过期。不过主服务器在和从服务器同步的时候会清空从服务器的数据，所以一般来说也没什么影响。</li>
</ul>
<h3 id="AOF模式"><a href="#AOF模式" class="headerlink" title="AOF模式"></a>AOF模式</h3><p>当以AOF持久化模式运行时，键只有被删除的时候才会向AOF文件追加一条DEL命令。</p>
<p>在执行AOF重写的过程中，程序也会检查键是否过期，只读取未过期的键。</p>
<h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><p>当运行在复制模式下时，从服务器的过期键删除操作由主服务器控制。</p>
<ul>
<li>主服务器在删除过期键的时候会主动向所有的从服务器发送DEL命令</li>
<li>从服务器读写键值的时候，依然会返回过期键，只有在接到DEL命令的时候才会删除过期键。</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知是Redis 2.8新增的功能，可以让客户端通过订阅的方式获得键的变化与命令执行情况。发送通知的功能是通过notify.c/notifyKeyspaceEvent函数实现的。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag">#Redis</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/13/Redis设计与实现——RDB持久化/" rel="prev">Redis设计与实现——RDB持久化</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/30/Redis设计与实现——SDS哈希表/" rel="next">Redis设计与实现——SDS哈希表</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/06/04/Redis设计与实现——数据库列表与结构体/"
     data-title="Redis设计与实现——数据库列表与结构体"
     data-content=""
     data-url="http://www.shenjianan.net/2016/06/04/Redis设计与实现——数据库列表与结构体/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="2016/06/04/Redis设计与实现——数据库列表与结构体/"
                   data-title="Redis设计与实现——数据库列表与结构体" data-url="http://www.shenjianan.net/2016/06/04/Redis设计与实现——数据库列表与结构体/">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xirbw.com1.z0.glb.clouddn.com/totoro.jpg" alt="沈佳楠" itemprop="image"/>
          <p class="site-author-name" itemprop="name">沈佳楠</p>
        </div>
        <p class="site-description motion-element" itemprop="description">点滴收获</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cat94" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="shenjianan@126.com" target="_blank">email</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="shen_jianan" target="_blank">WeChat</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库列表"><span class="nav-number">1.1.</span> <span class="nav-text">数据库列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redisDb结构"><span class="nav-number">1.2.</span> <span class="nav-text">redisDb结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis过期键删除策略"><span class="nav-number">1.3.</span> <span class="nav-text">Redis过期键删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性删除"><span class="nav-number">1.3.1.</span> <span class="nav-text">惰性删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF、EDB和复制功能对过期键的处理"><span class="nav-number">1.4.</span> <span class="nav-text">AOF、EDB和复制功能对过期键的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB模式"><span class="nav-number">1.4.1.</span> <span class="nav-text">RDB模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF模式"><span class="nav-number">1.4.2.</span> <span class="nav-text">AOF模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制模式"><span class="nav-number">1.4.3.</span> <span class="nav-text">复制模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库通知"><span class="nav-number">1.5.</span> <span class="nav-text">数据库通知</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沈佳楠</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shenjianan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
