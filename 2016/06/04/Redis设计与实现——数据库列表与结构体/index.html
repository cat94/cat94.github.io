<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Redis设计与实现——数据库列表与结构体 · 沈小黑的菜园</title><meta name="description" content="数据库数据库列表redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。
一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。

12345678910111213struct redisServer &amp;#123"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis设计与实现——数据库列表与结构体</a></h3></div><div class="post-content"><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库列表"><a href="#数据库列表" class="headerlink" title="数据库列表"></a>数据库列表</h2><p>redis.h/redisServer是Redis服务器的数据结构，保存所有的服务器状态。</p>
<p>一个Redis服务器默认会创建16个数据库，redisServer里面有数据库列表指针和数据库数量的记录。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line"></div><div class="line">	<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库</span></div><div class="line">    redisDb *db;</div><div class="line">    </div><div class="line">    <span class="comment">//...</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> dbnum;                      <span class="comment">/* Total number of configured DBs */</span></div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>redis.h/redisClient在切换数据库的时候，就会将redisClient中的db指针指向具体的数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisClient &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	</div><div class="line">	<span class="comment">// 当前正在使用的数据库</span></div><div class="line">	redisDb *db;</div><div class="line">	</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125; redisClient;</div></pre></td></tr></table></figure>
<h2 id="redisDb结构"><a href="#redisDb结构" class="headerlink" title="redisDb结构"></a>redisDb结构</h2><p>redis.h/redisDb表示一个数据库，其中包含有当前数据库所有的键值对、键的过期时间字典、阻塞中的键、可以解除阻塞的键、正被监视的键和数据库号码等信息。相对redisServer和redisClient来说是很简单的数据结构，主要就是服务于键值处理。其中的键值都只是指针，真正的键值对象都在别处分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Redis database representation. There are multiple databases identified</span></div><div class="line"> * by integers from 0 (the default database) up to the max configured</div><div class="line"> * database. The database number is the 'id' field in the structure. */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></div><div class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></div><div class="line"></div><div class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></div><div class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正处于阻塞状态的键</span></div><div class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line"></div><div class="line">    <span class="comment">// 可以解除阻塞的键</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line"></div><div class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></div><div class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> evictionPoolEntry *eviction_pool;    <span class="comment">/* Eviction pool of keys */</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库号码</span></div><div class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></div><div class="line"></div><div class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></div><div class="line"></div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>增删改查实际上就是对dict和dict指向的键值进行的操作，在对数据库进行读写的时候，服务器还会更新命中次数、不命中次数和LRU。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer&#123;</div><div class="line"></div><div class="line">	<span class="comment">//...</span></div><div class="line">	</div><div class="line">    <span class="comment">// 最近一次使用时钟</span></div><div class="line">    <span class="keyword">unsigned</span> lruclock:REDIS_LRU_BITS; <span class="comment">/* Clock for LRU eviction */</span></div><div class="line">	</div><div class="line">	<span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="comment">// 成功查找键的次数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_hits;   <span class="comment">/* Number of successful lookups of keys */</span></div><div class="line"></div><div class="line">    <span class="comment">// 查找键失败的次数</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_misses; <span class="comment">/* Number of failed lookups of keys */</span></div><div class="line">    </div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在读写之前，服务器会先检查是否过期，如果过期则需要删除这个键，下面是getCommand底层依赖的取值方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 为执行读取操作而取出键 key 在数据库 db 中的值。</div><div class="line"> *</div><div class="line"> * 并根据是否成功找到值，更新服务器的命中/不命中信息。</div><div class="line"> *</div><div class="line"> * 找到时返回值对象，没找到返回 NULL 。</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    <span class="comment">// 检查 key 释放已经过期</span></div><div class="line">    expireIfNeeded(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 从数据库中取出键的值</span></div><div class="line">    val = lookupKey(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 更新命中/不命中信息</span></div><div class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        server.stat_keyspace_hits++;</div><div class="line"></div><div class="line">    <span class="comment">// 返回值</span></div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于WATCH键，被WATCH命令监视的键都会被标记为dirty，每修改一个键之后，都会对dirty键计数器的值增1，这个计数器会出发服务器的持久化以及复制操作。</p>
<h2 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h2><p>Redis使用惰性删除和定期删除两种策略。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>db.c中的方法都是数据库级别的操作，比如过期时间、清空键、数据库大小、覆写等。</p>
<p>惰性删除的函数实现是db.c/expireIfNeeded。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 检查 key 是否已经过期，如果是的话，将它从数据库中删除。</div><div class="line"> *</div><div class="line"> * 返回 0 表示键没有过期时间，或者键未过期。</div><div class="line"> *</div><div class="line"> * 返回 1 表示键已经因为过期而被删除了。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 取出键的过期时间</span></div><div class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</div><div class="line">    <span class="keyword">mstime_t</span> now;</div><div class="line"></div><div class="line">    <span class="comment">// 没有过期时间说明永不过期</span></div><div class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></div><div class="line">    <span class="comment">// 如果服务器正在进行载入，那么不进行任何过期检查</span></div><div class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></div><div class="line">     * blocked to when the Lua script started. This way a key can expire</div><div class="line">     * only the first time it is accessed and not in the middle of the</div><div class="line">     * script execution, making propagation to slaves / AOF consistent.</div><div class="line">     * See issue #1525 on Github for more information. */</div><div class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</div><div class="line"></div><div class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></div><div class="line">     * the slave key expiration is controlled by the master that will</div><div class="line">     * send us synthesized DEL operations for expired keys.</div><div class="line">     *</div><div class="line">     * Still we try to return the right information to the caller, </div><div class="line">     * that is, 0 if we think the key should be still valid, 1 if</div><div class="line">     * we think the key is expired at this time. */</div><div class="line">    <span class="comment">// 当服务器运行在 replication 模式时</span></div><div class="line">    <span class="comment">// 附属节点并不主动删除 key</span></div><div class="line">    <span class="comment">// 它只返回一个逻辑上正确的返回值</span></div><div class="line">    <span class="comment">// 真正的删除操作要等待主节点发来删除命令时才执行</span></div><div class="line">    <span class="comment">// 从而保证数据的同步</span></div><div class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</div><div class="line"></div><div class="line">    <span class="comment">// 运行到这里，表示键带有过期时间，并且服务器为主节点</span></div><div class="line"></div><div class="line">    <span class="comment">/* Return when this key has not expired */</span></div><div class="line">    <span class="comment">// 如果未过期，返回 0</span></div><div class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Delete the key */</span></div><div class="line">    server.stat_expiredkeys++;</div><div class="line"></div><div class="line">    <span class="comment">// 向 AOF 文件和附属节点传播过期信息</span></div><div class="line">    propagateExpire(db,key);</div><div class="line"></div><div class="line">    <span class="comment">// 发送事件通知</span></div><div class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</div><div class="line"></div><div class="line">    <span class="comment">// 将过期键从数据库中删除</span></div><div class="line">    <span class="keyword">return</span> dbDelete(db,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单单使用惰性删除会导致过期但是不再被访问的键占用大量空间，因此还需要使用定期删除来周期性地删除过期键。定期删除的函数是redis.c/activeExpireCycle，下面是被它调用的activeExpireCycleTryExpire:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ======================= Cron: called every 100 ms ======================== */</span></div><div class="line"></div><div class="line"><span class="comment">/* Helper function for the activeExpireCycle() function.</span></div><div class="line"> * This function will try to expire the key that is stored in the hash table</div><div class="line"> * entry 'de' of the 'expires' hash table of a Redis database.</div><div class="line"> *</div><div class="line"> * activeExpireCycle() 函数使用的检查键是否过期的辅佐函数。</div><div class="line"> *</div><div class="line"> * If the key is found to be expired, it is removed from the database and</div><div class="line"> * 1 is returned. Otherwise no operation is performed and 0 is returned.</div><div class="line"> *</div><div class="line"> * 如果 de 中的键已经过期，那么移除它，并返回 1 ，否则不做动作，并返回 0 。</div><div class="line"> *</div><div class="line"> * When a key is expired, server.stat_expiredkeys is incremented.</div><div class="line"> *</div><div class="line"> * The parameter 'now' is the current time in milliseconds as is passed</div><div class="line"> * to the function to avoid too many gettimeofday() syscalls.</div><div class="line"> *</div><div class="line"> * 参数 now 是毫秒格式的当前时间</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">activeExpireCycleTryExpire</span><span class="params">(redisDb *db, dictEntry *de, <span class="keyword">long</span> <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取键的过期时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = dictGetSignedIntegerVal(de);</div><div class="line">    <span class="keyword">if</span> (now &gt; t) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 键已过期</span></div><div class="line"></div><div class="line">        sds key = dictGetKey(de);</div><div class="line">        robj *keyobj = createStringObject(key,sdslen(key));</div><div class="line"></div><div class="line">        <span class="comment">// 传播过期命令</span></div><div class="line">        propagateExpire(db,keyobj);</div><div class="line">        <span class="comment">// 从数据库中删除该键</span></div><div class="line">        dbDelete(db,keyobj);</div><div class="line">        <span class="comment">// 发送事件</span></div><div class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">            <span class="string">"expired"</span>,keyobj,db-&gt;id);</div><div class="line">        decrRefCount(keyobj);</div><div class="line">        <span class="comment">// 更新计数器</span></div><div class="line">        server.stat_expiredkeys++;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 键未过期</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的dbDelete会删除这个数据库里面的过期时间、键值对，但是decrRefCount不一定会释放这个值的内存，因为可能有别的值引用了这个对象。只有当refCount降到0的时候，才会释放它的内存。下面是db.c/decrRefCount的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB </span></div><div class="line"> *</div><div class="line"> * 从数据库中删除给定的键，键的值，以及键的过期时间。</div><div class="line"> *</div><div class="line"> * 删除成功返回 1 ，因为键不存在而导致删除失败时，返回 0 。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></div><div class="line">     * the key, because it is shared with the main dictionary. */</div><div class="line">    <span class="comment">// 删除键的过期时间</span></div><div class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 删除键值对</span></div><div class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</div><div class="line">        <span class="comment">// 如果开启了集群模式，那么从槽中删除给定的键</span></div><div class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 键不存在</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是定期删除过期键的函数activeExpireCycle，它不会强求一次性将所有的过期键删除，而是在一个规定的时间内删除一部分的过期时间，并且在一段时间后再启动。在前期的启动模式判断、变量初始化之后，计算轮到清理的数据库，并且将数据库号加一，也就是说就算数据库0没有在当前时限内处理完毕，下次也依旧会处理数据库1，相当于时间片轮转的清理方式。</p>
<p>在对数据库进行清理之前，代码会先检查带有过期时间的键值对数量，记录当前时间，如果所有键值对都是永不过期的或者可过期键值对占比小于1%，那就直接跳过这个数据库；如果可过期键数量M超过<strong>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</strong>，还要只检查<strong>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</strong>个键。在这之后，进行M次循环，每次循环随机取一个键，如果已经过期则删除之(调用activeExpireCycleTryExpire)，更新统计数据。每进行16次遍历，就检查是否已经超过时间限制，如果超过则结束此过程。</p>
<p>最后，每次遍历都会进行检查。如果已经删除了带过期时间键数量的25%，则不再进行遍历，转而处理下一个数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Try to expire a few timed out keys. The algorithm used is adaptive and</span></div><div class="line"> * will use few CPU cycles if there are few expiring keys, otherwise</div><div class="line"> * it will get more aggressive to avoid that too much memory is used by</div><div class="line"> * keys that can be removed from the keyspace.</div><div class="line"> *</div><div class="line"> * 函数尝试删除数据库中已经过期的键。</div><div class="line"> * 当带有过期时间的键比较少时，函数运行得比较保守，</div><div class="line"> * 如果带有过期时间的键比较多，那么函数会以更积极的方式来删除过期键，</div><div class="line"> * 从而可能地释放被过期键占用的内存。</div><div class="line"> *</div><div class="line"> * No more than REDIS_DBCRON_DBS_PER_CALL databases are tested at every</div><div class="line"> * iteration.</div><div class="line"> *</div><div class="line"> * 每次循环中被测试的数据库数目不会超过 REDIS_DBCRON_DBS_PER_CALL 。</div><div class="line"> *</div><div class="line"> * This kind of call is used when Redis detects that timelimit_exit is</div><div class="line"> * true, so there is more work to do, and we do it more incrementally from</div><div class="line"> * the beforeSleep() function of the event loop.</div><div class="line"> *</div><div class="line"> * 如果 timelimit_exit 为真，那么说明还有更多删除工作要做，</div><div class="line"> * 那么在 beforeSleep() 函数调用时，程序会再次执行这个函数。</div><div class="line"> *</div><div class="line"> * Expire cycle type:</div><div class="line"> *</div><div class="line"> * 过期循环的类型：</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a</div><div class="line"> * "fast" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION</div><div class="line"> * microseconds, and is not repeated again before the same amount of time.</div><div class="line"> *</div><div class="line"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_FAST ，</div><div class="line"> * 那么函数会以“快速过期”模式执行，</div><div class="line"> * 执行的时间不会长过 EXPIRE_FAST_CYCLE_DURATION 毫秒，</div><div class="line"> * 并且在 EXPIRE_FAST_CYCLE_DURATION 毫秒之内不会再重新执行。</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is</div><div class="line"> * executed, where the time limit is a percentage of the REDIS_HZ period</div><div class="line"> * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. </div><div class="line"> *</div><div class="line"> * 如果循环的类型为 ACTIVE_EXPIRE_CYCLE_SLOW ，</div><div class="line"> * 那么函数会以“正常过期”模式执行，</div><div class="line"> * 函数的执行时限为 REDIS_HS 常量的一个百分比，</div><div class="line"> * 这个百分比由 REDIS_EXPIRELOOKUPS_TIME_PERC 定义。</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></div><div class="line">     * incrementally across calls. */</div><div class="line">    <span class="comment">// 静态变量，用来累积函数连续执行时的数据</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 默认每次处理的数据库数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</div><div class="line">    <span class="comment">// 函数开始的时间</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit;</div><div class="line"></div><div class="line">    <span class="comment">// 快速模式</span></div><div class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</div><div class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exited</span></div><div class="line">         * for time limt. Also don't repeat a fast cycle for the same period</div><div class="line">         * as the fast cycle total duration itself. */</div><div class="line">        <span class="comment">// 如果上次函数没有触发 timelimit_exit ，那么不执行处理</span></div><div class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 如果距离上次执行未够一定时间，那么不执行处理</span></div><div class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 运行到这里，说明执行快速处理，记录当前时间</span></div><div class="line">        last_fast_cycle = start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</span></div><div class="line">     * two exceptions:</div><div class="line">     *</div><div class="line">     * 一般情况下，函数只处理 REDIS_DBCRON_DBS_PER_CALL 个数据库，</div><div class="line">     * 除非：</div><div class="line">     *</div><div class="line">     * 1) Don't test more DBs than we have.</div><div class="line">     *    当前数据库的数量小于 REDIS_DBCRON_DBS_PER_CALL</div><div class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</div><div class="line">     * in this iteration, as there is work to do in some DB and we don't want</div><div class="line">     * expired keys to use memory for too much time. </div><div class="line">     *     如果上次处理遇到了时间上限，那么这次需要对所有数据库进行扫描，</div><div class="line">     *     这可以避免过多的过期键占用空间</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</div><div class="line">        dbs_per_call = server.dbnum;</div><div class="line"></div><div class="line">    <span class="comment">/* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</span></div><div class="line">     * per iteration. Since this function gets called with a frequency of</div><div class="line">     * server.hz times per second, the following is the max amount of</div><div class="line">     * microseconds we can spend in this function. */</div><div class="line">    <span class="comment">// 函数处理的微秒时间上限</span></div><div class="line">    <span class="comment">// ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 默认为 25 ，也即是 25 % 的 CPU 时间</span></div><div class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</div><div class="line">    timelimit_exit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果是运行在快速模式之下</span></div><div class="line">    <span class="comment">// 那么最多只能运行 FAST_DURATION 微秒 </span></div><div class="line">    <span class="comment">// 默认值为 1000 （微秒）</span></div><div class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</div><div class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></div><div class="line"></div><div class="line">    <span class="comment">// 遍历数据库</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</div><div class="line">        <span class="keyword">int</span> expired;</div><div class="line">        <span class="comment">// 指向要处理的数据库</span></div><div class="line">        redisDb *db = server.db+(current_db % server.dbnum);</div><div class="line"></div><div class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></div><div class="line">         * in the current DB we'll restart from the next. This allows to</div><div class="line">         * distribute the time evenly across DBs. */</div><div class="line">        <span class="comment">// 为 DB 计数器加一，如果进入 do 循环之后因为超时而跳出</span></div><div class="line">        <span class="comment">// 那么下次会直接从下个 DB 开始处理</span></div><div class="line">        current_db++;</div><div class="line"></div><div class="line">        <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></div><div class="line">         * of the keys were expired. */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</div><div class="line">            <span class="keyword">int</span> ttl_samples;</div><div class="line"></div><div class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></div><div class="line">            <span class="comment">// 获取数据库中带过期时间的键的数量</span></div><div class="line">            <span class="comment">// 如果该数量为 0 ，直接跳过这个数据库</span></div><div class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</div><div class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取数据库中键值对的数量</span></div><div class="line">            slots = dictSlots(db-&gt;expires);</div><div class="line">            <span class="comment">// 当前时间</span></div><div class="line">            now = mstime();</div><div class="line"></div><div class="line">            <span class="comment">/* When there are less than 1% filled slots getting random</span></div><div class="line">             * keys is expensive, so stop here waiting for better times...</div><div class="line">             * The dictionary will be resized asap. */</div><div class="line">            <span class="comment">// 这个数据库的使用率低于 1% ，扫描起来太费力了（大部分都会 MISS）</span></div><div class="line">            <span class="comment">// 跳过，等待字典收缩程序运行</span></div><div class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></div><div class="line">             * with an expire set, checking for expired ones. </div><div class="line">             *</div><div class="line">             * 样本计数器</div><div class="line">             */</div><div class="line">            <span class="comment">// 已处理过期键计数器</span></div><div class="line">            expired = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 键的总 TTL 计数器</span></div><div class="line">            ttl_sum = <span class="number">0</span>;</div><div class="line">            <span class="comment">// 总共处理的键计数器</span></div><div class="line">            ttl_samples = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 每次最多只能检查 LOOKUPS_PER_LOOP 个键</span></div><div class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</div><div class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</div><div class="line"></div><div class="line">            <span class="comment">// 开始遍历数据库</span></div><div class="line">            <span class="keyword">while</span> (num--) &#123;</div><div class="line">                dictEntry *de;</div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</div><div class="line"></div><div class="line">                <span class="comment">// 从 expires 中随机取出一个带过期时间的键</span></div><div class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</div><div class="line">                <span class="comment">// 计算 TTL</span></div><div class="line">                ttl = dictGetSignedIntegerVal(de)-now;</div><div class="line">                <span class="comment">// 如果键已经过期，那么删除它，并将 expired 计数器增一</span></div><div class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</div><div class="line">                <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) ttl = <span class="number">0</span>;</div><div class="line">                <span class="comment">// 累积键的 TTL</span></div><div class="line">                ttl_sum += ttl;</div><div class="line">                <span class="comment">// 累积处理键的个数</span></div><div class="line">                ttl_samples++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></div><div class="line">            <span class="comment">// 为这个数据库更新平均 TTL 统计数据</span></div><div class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</div><div class="line">                <span class="comment">// 计算当前平均值</span></div><div class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果这是第一次设置数据库平均 TTL ，那么进行初始化</span></div><div class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</div><div class="line">                <span class="comment">/* Smooth the value averaging with the previous one. */</span></div><div class="line">                <span class="comment">// 取数据库的上次平均 TTL 和今次平均 TTL 的平均值</span></div><div class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/<span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* We can't block forever here even if there are many keys to</span></div><div class="line">             * expire. So after a given amount of milliseconds return to the</div><div class="line">             * caller waiting for the other active expire cycle. */</div><div class="line">            <span class="comment">// 我们不能用太长时间处理过期键，</span></div><div class="line">            <span class="comment">// 所以这个函数执行一定时间之后就要返回</span></div><div class="line"></div><div class="line">            <span class="comment">// 更新遍历次数</span></div><div class="line">            iteration++;</div><div class="line"></div><div class="line">            <span class="comment">// 每遍历 16 次执行一次</span></div><div class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span> &amp;&amp; <span class="comment">/* check once every 16 iterations. */</span></div><div class="line">                (ustime()-start) &gt; timelimit)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">// 如果遍历次数正好是 16 的倍数</span></div><div class="line">                <span class="comment">// 并且遍历的时间超过了 timelimit</span></div><div class="line">                <span class="comment">// 那么断开 timelimit_exit</span></div><div class="line">                timelimit_exit = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 已经超时了，返回</span></div><div class="line">            <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* We don't repeat the cycle if there are less than 25% of keys</span></div><div class="line">             * found expired in the current DB. */</div><div class="line">            <span class="comment">// 如果已删除的过期键占当前总数据库带过期时间的键数量的 25 %</span></div><div class="line">            <span class="comment">// 那么不再遍历</span></div><div class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AOF、EDB和复制功能对过期键的处理"><a href="#AOF、EDB和复制功能对过期键的处理" class="headerlink" title="AOF、EDB和复制功能对过期键的处理"></a>AOF、EDB和复制功能对过期键的处理</h2><h3 id="RDB模式"><a href="#RDB模式" class="headerlink" title="RDB模式"></a>RDB模式</h3><p>执行SAVE或者BGSAVE的时候，程序会将未过期的键值保存到新创建的RDB文件中。而当启动Redis的时候，只要开启了RDB功能，那么就会载入RDB文件。</p>
<ul>
<li>如果是主服务器，那么载入时会对保存的键进行检查，只读取未过期的键。</li>
<li>如果是从服务器，那么不会检查是否过期。不过主服务器在和从服务器同步的时候会清空从服务器的数据，所以一般来说也没什么影响。</li>
</ul>
<h3 id="AOF模式"><a href="#AOF模式" class="headerlink" title="AOF模式"></a>AOF模式</h3><p>当以AOF持久化模式运行时，键只有被删除的时候才会向AOF文件追加一条DEL命令。</p>
<p>在执行AOF重写的过程中，程序也会检查键是否过期，只读取未过期的键。</p>
<h3 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h3><p>当运行在复制模式下时，从服务器的过期键删除操作由主服务器控制。</p>
<ul>
<li>主服务器在删除过期键的时候会主动向所有的从服务器发送DEL命令</li>
<li>从服务器读写键值的时候，依然会返回过期键，只有在接到DEL命令的时候才会删除过期键。</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知是Redis 2.8新增的功能，可以让客户端通过订阅的方式获得键的变化与命令执行情况。发送通知的功能是通过notify.c/notifyKeyspaceEvent函数实现的。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-06-04</span><i class="fa fa-tag"></i><a href="/tags/Redis/" title="Redis" class="tag">Redis </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2016/06/04/Redis设计与实现——数据库列表与结构体/,沈小黑的菜园,Redis设计与实现——数据库列表与结构体,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/06/13/Redis设计与实现——RDB持久化/" title="Redis设计与实现——RDB持久化" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/05/30/Redis设计与实现——SDS哈希表/" title="Redis设计与实现——SDS哈希表" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>