<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Ben Wong,wenbinben@gmail.com"><title>Redis设计与实现——RDB持久化 · 沈小黑的菜园</title><meta name="description" content="RDB持久化RDB文件的创建与载入SAVE命令会阻塞Redis服务器进程，这期间不能处理任何命令。而BGSAVE会派生一个子进程，由子进程创建RDB文件。

1234567891011121314151617181920212223242526272829303132333435void saveC"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">沈小黑的菜园</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/Ben_wenbin"><i class="fa fa-twitter"></i></a></li><li><a href="http://instagram.com/hwbinbenben"><i class="fa fa-instagram"></i></a></li><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://weibo.com/ben0036"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="https://secure.gravatar.com/avatar/e71df8021446fe9759a9928b1dd5c28d?s=180&amp;r=G&amp;d="></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Redis设计与实现——RDB持久化</a></h3></div><div class="post-content"><h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>SAVE命令会阻塞Redis服务器进程，这期间不能处理任何命令。而BGSAVE会派生一个子进程，由子进程创建RDB文件。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// BGSAVE 已经在执行中，不能再执行 SAVE</span></div><div class="line">    <span class="comment">// 否则将产生竞争条件</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 执行 </span></div><div class="line">    <span class="keyword">if</span> (rdbSave(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReply(c,shared.ok);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgsaveCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 不能重复执行 BGSAVE</span></div><div class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Background save already in progress"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 不能在 BGREWRITEAOF 正在运行时执行</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</div><div class="line">        addReplyError(c,<span class="string">"Can't BGSAVE while AOF log rewriting is in progress"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 执行 BGSAVE</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">        addReplyStatus(c,<span class="string">"Background saving started"</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReply(c,shared.err);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建RDB文件的函数在rdb.c/rdbSave中，rdbSaveBackground是创建一个线程之后在子线程中调用rdbSave。rdbSave先创建一个临时文件，待创建完成之后再重命名覆盖原来的RDB文件。</p>
<p>写临时文件的过程则是不断遍历数据库，对于有键值对的数据库，写入REDIS_RDB_OPCODE_SELECTDB标识（表明切换数据库）之后，遍历追加键值和过期时间到临时文件中，在保存之前都会写入类型标识来表明接下来保存的是什么。最后写入REDIS_RDB_OPCODE_EOF标识，检验校验和，flush缓存，关闭文件。</p>
<p>AOF通常比RDB更新频率更高，所以如果开启了AOF，Redis服务器启动时默认会使用AOF来加载数据。从RDB文件加载数据的函数是rdb.c/rdbLoad。rdbLoad的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">def rdbLoad(*filename)&#123;</div><div class="line">	打开rdb文件并初始化写入流</div><div class="line">	</div><div class="line">	检查版本号</div><div class="line">	</div><div class="line">	服务器标记开始载入并计时</div><div class="line">	</div><div class="line">	while(1)&#123;</div><div class="line">		读入RDB数据标识，决定接下来读取的是什么类型的数据</div><div class="line">		读取过期时间与接下来的键值对</div><div class="line">		</div><div class="line">		if(type == REDIS_RDB_OPCODE_EOF)&#123;</div><div class="line">			break</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		if(type == REDIS_RDB_OPCODE_SELECTDB)&#123;</div><div class="line">			读取数据库号码</div><div class="line">			</div><div class="line">			检查号码正确性</div><div class="line">			</div><div class="line">			更新db指针到指定的数据库</div><div class="line">			</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		读入</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="rdb文件结构"><a href="#rdb文件结构" class="headerlink" title="rdb文件结构"></a>rdb文件结构</h2><p>RDB文件的结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>REDIS(字符串常量)</th>
<th>db_version</th>
<th>databases(数据库数据)</th>
<th>EOF(常量)</th>
<th>check_sum</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>其中REDIS常量是为了方便服务器判断文件是否为RDB文件，db_version是一个4字节的字符串表示的版本号，databases包含所有数据库的数据，EOF是长度为1字节的结束符，check_sum是校验和。</p>
<p>如果只有数据库0和数据库3有数据，那么扩展databases之后的结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>REDIS</th>
<th>db_version</th>
<th>database 0</th>
<th>database 3</th>
<th>EOF</th>
<th>check_sum</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>每个数据库的详细结构是这样的：</p>
<table>
<thead>
<tr>
<th></th>
<th>SELECTDB(字符串常量)</th>
<th>db_number</th>
<th>key_value_pairs</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>SELECTDB常量的长度为1字节，表明下面的数据是数据库号码。db_number根据号码的大小不同可以是1、2或者5字节长度。读入db_number之后程序就可以切换到指定的数据库了。key_value_pairs保存了所有的键值对数据，如果键值对带有过期时间，那么过期时间也会一并被记录下来。</p>
<h3 id="kay-value-pair部分"><a href="#kay-value-pair部分" class="headerlink" title="kay_value_pair部分"></a>kay_value_pair部分</h3><p>不带过期时间的键值对结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>TYPE</th>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>带有过期时间的键值对结构如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>EXPIRETIME_MS(字符串常量,1byte)</th>
<th>ms(8byte)</th>
<th>TYPE</th>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>TYPE记录的是value的类型，长度为1字节，在rdb.h中定义了类型的可取值范围：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Dup object types to RDB object types. Only reason is readability (are we</span></div><div class="line"> * dealing with RDB types or with in-memory object types?).</div><div class="line"> *</div><div class="line"> * 对象类型在 RDB 文件中的类型</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_STRING 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_LIST   1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_SET    2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_ZSET   3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_HASH   4</span></div><div class="line"></div><div class="line"><span class="comment">/* Object types for encoded objects.</span></div><div class="line"> *</div><div class="line"> * 对象的编码方式</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_HASH_ZIPMAP    9</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_LIST_ZIPLIST  10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_SET_INTSET    11</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_ZSET_ZIPLIST  12</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_RDB_TYPE_HASH_ZIPLIST  13</span></div></pre></td></tr></table></figure>
<p>在读入数据的时候会根据TYPE值来确定如何读入与解释这些数据，在rdb.c/rdbLoadObject中就包含了如何根据TYPE值读取与解释数据的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Load a Redis object of the specified type from the specified file.</span></div><div class="line"> *</div><div class="line"> * 从 rdb 文件中载入指定类型的对象。</div><div class="line"> *</div><div class="line"> * On success a newly allocated object is returned, otherwise NULL. </div><div class="line"> *</div><div class="line"> * 读入成功返回一个新对象，否则返回 NULL 。</div><div class="line"> */</div><div class="line"><span class="function">robj *<span class="title">rdbLoadObject</span><span class="params">(<span class="keyword">int</span> rdbtype, rio *rdb)</span> </span>&#123;</div><div class="line">    robj *o, *ele, *dec;</div><div class="line">    <span class="keyword">size_t</span> len;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">// 载入字符串对象</span></div><div class="line">    <span class="keyword">if</span> (rdbtype == REDIS_RDB_TYPE_STRING) &#123;</div><div class="line">        <span class="comment">/* Read string value */</span></div><div class="line">        <span class="keyword">if</span> ((o = rdbLoadEncodedStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        o = tryObjectEncoding(o);</div><div class="line"></div><div class="line">    <span class="comment">// 载入列表对象</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == REDIS_RDB_TYPE_LIST) &#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Read list value </span></div><div class="line">         *</div><div class="line">         * 读入列表的节点数</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> ((len = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == REDIS_RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* Use a real list when there are too many entries </span></div><div class="line">         *</div><div class="line">         * 根据节点数，创建对象的编码</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (len &gt; server.list_max_ziplist_entries) &#123;</div><div class="line">            o = createListObject();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            o = createZiplistObject();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Load every single element of the list </span></div><div class="line">         *</div><div class="line">         * 载入所有列表项</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span>(len--) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 载入字符串对象</span></div><div class="line">            <span class="keyword">if</span> ((ele = rdbLoadEncodedStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            <span class="comment">/* If we are using a ziplist and the value is too big, convert</span></div><div class="line">             * the object to a real list. </div><div class="line">             *</div><div class="line">             * 根据字符串对象，</div><div class="line">             * 检查是否需要将列表从 ZIPLIST 编码转换为 LINKEDLIST 编码</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</div><div class="line">                sdsEncodedObject(ele) &amp;&amp;</div><div class="line">                sdslen(ele-&gt;ptr) &gt; server.list_max_ziplist_value)</div><div class="line">                    listTypeConvert(o,REDIS_ENCODING_LINKEDLIST);</div><div class="line"></div><div class="line">            <span class="comment">// ZIPLIST</span></div><div class="line">            <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</div><div class="line">                dec = getDecodedObject(ele);</div><div class="line"></div><div class="line">                <span class="comment">// 将字符串值推入 ZIPLIST 末尾来重建列表</span></div><div class="line">                o-&gt;ptr = ziplistPush(o-&gt;ptr,dec-&gt;ptr,sdslen(dec-&gt;ptr),REDIS_TAIL);</div><div class="line"></div><div class="line">                decrRefCount(dec);</div><div class="line">                decrRefCount(ele);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 将新列表项推入到链表的末尾</span></div><div class="line">                ele = tryObjectEncoding(ele);</div><div class="line">                listAddNodeTail(o-&gt;ptr,ele);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 载入集合对象</span></div><div class="line">    <span class="comment">//还有很多不同类型的处理.....</span></div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="value编码"><a href="#value编码" class="headerlink" title="value编码"></a>value编码</h3><p>对于不同TYPE的value，它们value的结构、长度也会有所不同。</p>
<h4 id="REDIS-RDB-TYPE-STRING"><a href="#REDIS-RDB-TYPE-STRING" class="headerlink" title="REDIS_RDB_TYPE_STRING"></a>REDIS_RDB_TYPE_STRING</h4><p>这样的TYPE保存的是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p>
<p>REDIS_ENCODING_INT的内容格式，其中的ENCODING可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32。比如：</p>
<table>
<thead>
<tr>
<th></th>
<th>REDIS_RDB_ENC_INT8</th>
<th>123</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>而如果是REDIS_ENCODING_RAW的编码，那么保存的就是一个字符串值。在开启压缩功能的情况下，字符串值在长度小于等于20字节的时候直接原样保存，如果大于20字节则会被压缩后再保存。</p>
<p>没有被压缩的字符串结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>len</th>
<th>string</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>压缩的字符串结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>REDIS_RDB_ENC_LZF</th>
<th>compressed_len</th>
<th>origin_len</th>
<th>compressed_string</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>REDIS_RDB_ENC_LZF表明已经被LZF算法压缩。通过len变量或者compressed_len变量，程序得以判断字符串到哪个位置结束。</p>
<h4 id="REDIS-RDB-TYPE-LIST"><a href="#REDIS-RDB-TYPE-LIST" class="headerlink" title="REDIS_RDB_TYPE_LIST"></a>REDIS_RDB_TYPE_LIST</h4><p>这样的TYPE保存的是REDIS_ENCODING_LINKEDLIST编码的对象，RDB文件通过下面的结构保存这种对象：</p>
<table>
<thead>
<tr>
<th></th>
<th>list_length</th>
<th>item1</th>
<th>item2</th>
<th>….</th>
<th>itemN</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>list_length保存的是列表保存了多少项，而不是占用的内存长度——关于内存长度的记录在每个item中。由于LINKED_LIST中的每一项都是字符串，所以详细的结构是这样：</p>
<table>
<thead>
<tr>
<th></th>
<th>list_length</th>
<th>len</th>
<th>string</th>
<th>len</th>
<th>string</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="REDIS-RDB-TYPE-SET"><a href="#REDIS-RDB-TYPE-SET" class="headerlink" title="REDIS_RDB_TYPE_SET"></a>REDIS_RDB_TYPE_SET</h4><p>这个TYPE代表集合，value保存的是REDIS_ENCODING_HT编码的集合对象。结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>set_size</th>
<th>elem1</th>
<th>elem2</th>
<th>…</th>
<th>elemN</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>每个集合元素都是字符串对象，所以它的结构和上面的REDSI_RDB_TYPE_LIST结构很像。</p>
<h4 id="REDIS-RDB-TYPE-HASH"><a href="#REDIS-RDB-TYPE-HASH" class="headerlink" title="REDIS_RDB_TYPE_HASH"></a>REDIS_RDB_TYPE_HASH</h4><p>这个TYPE的哈希表类型保存的也是REDIS_ENCODING_HT编码的集合对象。结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>hash_size</th>
<th>key_value_pair 1</th>
<th>key_value_pair 2</th>
<th>…</th>
<th>key_value_pair 3</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>键值对的结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>所以一个哈希表的例子如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th>1</th>
<th>“a”</th>
<th>5</th>
<th>“apple”</th>
<th>1</th>
<th>“b”</th>
<th>6</th>
<th>“banana”</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="REDIS-RDB-TYPE-ZSET"><a href="#REDIS-RDB-TYPE-ZSET" class="headerlink" title="REDIS_RDB_TYPE_ZSET"></a>REDIS_RDB_TYPE_ZSET</h4><p>这个TYPE的有序集合保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>sorted_set_size</th>
<th>elem1</th>
<th>elem2</th>
<th>…</th>
<th>elemN</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>一个element的结构又如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>member1</th>
<th>score1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>每一个member和score都是一个字符串，下面是一个有序集合的例子，member分别为pi和e，score分别为3.14和2.7：</p>
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th>2</th>
<th>“pi”</th>
<th>4</th>
<th>“3.14”</th>
<th>1</th>
<th>“e”</th>
<th>3</th>
<th>“2.7”</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h4 id="REDIS-RDB-TYPE-SET-INTSET"><a href="#REDIS-RDB-TYPE-SET-INTSET" class="headerlink" title="REDIS_RDB_TYPE_SET_INTSET"></a>REDIS_RDB_TYPE_SET_INTSET</h4><p>REDIS_RDB_TYPE_SET_INTSET表明是整数集合对象，RDB文件先将整数集合转换为字符串对象，然后将字符串对象保存到RDB文件中。</p>
<h4 id="REDIS-RDB-TYPE-LIST-ZIPLIST、REDIS-RDB-TYPE-HASH-ZIPLIST、REDIS-RDB-TYPE-ZSET-ZIPLIST"><a href="#REDIS-RDB-TYPE-LIST-ZIPLIST、REDIS-RDB-TYPE-HASH-ZIPLIST、REDIS-RDB-TYPE-ZSET-ZIPLIST" class="headerlink" title="REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST、REDIS_RDB_TYPE_ZSET_ZIPLIST"></a>REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST、REDIS_RDB_TYPE_ZSET_ZIPLIST</h4><p>RDB将压缩列表转换成一个字符串对象，然后将字符串对象保存到RDB文件。读入的时候根据类型恢复为相对应的对象。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-06-13</span><i class="fa fa-tag"></i><a href="/tags/Redis/" title="Redis" class="tag">Redis </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://www.shenjianan.net/2016/06/13/Redis设计与实现——RDB持久化/,沈小黑的菜园,Redis设计与实现——RDB持久化,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/06/13/Redis设计与实现——AOF持久化/" title="Redis设计与实现——AOF持久化" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/06/04/Redis设计与实现——数据库列表与结构体/" title="Redis设计与实现——数据库列表与结构体" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>