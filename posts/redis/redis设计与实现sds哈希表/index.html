<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>
Redis设计与实现——SDS哈希表
</title>

    
  <link href="https://shenjianan-blog.oss-cn-beijing.aliyuncs.com/avatars/totoro3.jpeg?x-oss-process=style/icon" rel="shortcut icon" type="image/x-icon" />



  
  <meta name="author" content="Shen Jianan" />
  <meta name="description" content="哈希表 dictht结构体定义了一个哈希表，保存着指向dictEntry的指针的数组。通过使用链表来解决哈希冲突。
dict结构体是字典的结构体，每个字典有两个哈希表，便于在rehash的时候依然可以进行遍历操作。dict使用safe值来标记当前是否是安全状态，用table值标记当前被迭代的哈希表号码。
" />



<meta name="generator" content="Hugo 0.68.3" />

<link rel="canonical" href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0sds%E5%93%88%E5%B8%8C%E8%A1%A8/" />


<meta property="og:title" content="Redis设计与实现——SDS哈希表" />
<meta property="og:description" content="哈希表
dictht结构体定义了一个哈希表，保存着指向dictEntry的指针的数组。通过使用链表来解决哈希冲突。
dict结构体是字典的结构体，每个字典有两个哈希表，便于在rehash的时候依然可以进行遍历操作。dict使用safe值来标记当前是否是安全状态，用table值标记当前被迭代的哈希表号码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0sds%E5%93%88%E5%B8%8C%E8%A1%A8/" />
<meta property="article:published_time" content="2016-05-30T21:37:23+00:00" />
<meta property="article:modified_time" content="2016-05-30T21:37:23+00:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis设计与实现——SDS哈希表"/>
<meta name="twitter:description" content="哈希表
dictht结构体定义了一个哈希表，保存着指向dictEntry的指针的数组。通过使用链表来解决哈希冲突。
dict结构体是字典的结构体，每个字典有两个哈希表，便于在rehash的时候依然可以进行遍历操作。dict使用safe值来标记当前是否是安全状态，用table值标记当前被迭代的哈希表号码。"/>


<link rel="stylesheet" href="/css/github-markdown.css" />
<link rel="stylesheet" href="/css/semantic.min.css" />
<link rel="stylesheet" href="/css/site.css" />





  </head>

  
  <body style="background-image: url(https://shenjianan-blog.oss-cn-beijing.aliyuncs.com/bg/mountains-covered-in-snow-mid.jpg);">
  
    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          
<nav class="ui secondary menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="Flip it!"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="Home" onclick="window.location.href = 'http:\/\/www.shenjianan.top\/'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          
<div class="ui centered relaxed grid dream-grid">
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single">

    <section class="ui top attached segment" id="dream-save-post-as-img">
      <header style="margin-top: 0 !important;">
        <h2 class="ui header">
          Redis设计与实现——SDS哈希表
          <div class="sub header">@ Shen Jianan · Monday, May 30, 2016 · 11 minute read · Update at May 30, 2016</div>
        </h2>
      </header>
      <article style="margin-top: 2rem;"><h1 id="哈希表">哈希表</h1>
<p>dictht结构体定义了一个哈希表，保存着指向dictEntry的指针的数组。通过使用链表来解决哈希冲突。</p>
<p>dict结构体是字典的结构体，每个字典有两个哈希表，便于在rehash的时候依然可以进行遍历操作。dict使用safe值来标记当前是否是安全状态，用table值标记当前被迭代的哈希表号码。</p>
<h2 id="渐进式rehash">渐进式rehash</h2>
<p>当哈希表很大的时候，不能一下子将所有的键都哈希完成，这时候就需要让字典同时持有两个哈希表，然后用rehashidx标记哈希的进度。每次对字典进行添加、删除、查找或者更新操作的时候顺便将rehashidx上的键值rehash到ht[1]。在进行添加的时候，直接将值添加到ht[1]中，以保证不会遗漏值。</p>
<h1 id="跳跃表">跳跃表</h1>
<p><a href="https://blog.csdn.net/yang_yulei/article/details/46275283">跳跃表</a>是可以和平衡树相媲美的数据结构，但是结构比平衡树简单。缺点是比较占用内存。Redis虽然是单线程，但是在以后可能需要多线程，多线程情况下平衡树的再平衡会影响更多的节点，导致更激烈的锁竞争。</p>
<p>Redis只在有序集合和集群节点中用到了这个数据结构。</p>
<p>在Redis中每个节点的层数是根据幂次定律(越大的数出现的概率越小)随机生成的(1~32)，然后从表头依次连接每一层，就成为一个跳跃表了。其中的跨度只是单纯为了计算排位的。</p>
<h1 id="压缩列表">压缩列表</h1>
<p>Redis自己实现的一种压缩型列表，entry节点之间都紧密排列，每个entry节点保存前面一个节点的内存大小、自己节点的编码和内容。</p>
<p>由于内容长度的不同，previous_entry_length可能是1字节也可能是5字节。</p>
<p>对于不同的编码类型，使用专门的代码编号指代。</p>
<p>在entry被修改的时候，可能导致内容长度改变进而导致previous_entry_length的长度改变，从而后续的entry。有可能导致整个表中previous_entry_length都因为无法表示而改变长度。</p>
<p>压缩列表在添加/删除节点的时候需要realloc内存，所以效率不是特别高。</p>
<h1 id="整数集合intset">整数集合(intset)</h1>
<p>当集合的元素不多且都是整数值元素时，使用的是intset。</p>
<p>结构体包括：编码方式、元素数量与保存元素的数组这三个实例。虽然contents是int8_t类型的，但是实际上是根据encoding尺寸来读取contents内容。</p>
<h1 id="对象">对象</h1>
<p>Redis不直接操作数据结构，而是通过对象来操作这些数据结构。在不同的场景下可以使用不同的数据结构来实现对象。</p>
<p>Redis对象还使用引用计数进行内存回收与对象共享。下面是编码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 对象编码
</span><span style="color:#75715e"></span><span style="color:#75715e">#define REDIS_ENCODING_RAW 0     </span><span style="color:#75715e">/* Raw representation */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_INT 1     </span><span style="color:#75715e">/* Encoded as integer */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_HT 2      </span><span style="color:#75715e">/* Encoded as hash table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_ZIPMAP 3  </span><span style="color:#75715e">/* Encoded as zipmap */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_LINKEDLIST 4 </span><span style="color:#75715e">/* Encoded as regular linked list */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_ZIPLIST 5 </span><span style="color:#75715e">/* Encoded as ziplist */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_INTSET 6  </span><span style="color:#75715e">/* Encoded as intset */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_SKIPLIST 7  </span><span style="color:#75715e">/* Encoded as skiplist */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define REDIS_ENCODING_EMBSTR 8  </span><span style="color:#75715e">/* Embedded sds string encoding */</span><span style="color:#75715e">
</span></code></pre></div><p>REDIS_ENCODING_RAW是简单的对象，就是将ptr指向的数据结构包装成一个对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个新 robj 对象
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createObject</span>(<span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) {

    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>o));

    o<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> type;
    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_RAW;
    o<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> ptr;
    o<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">/* Set the LRU to the current lruclock (minutes resolution). */</span>
    o<span style="color:#f92672">-&gt;</span>lru <span style="color:#f92672">=</span> LRU_CLOCK();
    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div><p>REDIS_ENCODING_HT可以用来创建REDIS_HASH或者REDIS_SET。下面是用REDIS_ENCODING_HT的编码创建REDIS_SET的源代码，也很简单，实际上是利用了dictCreate创建一个dict基本类型，然后利用createObject方法创建一个robj，然后修改encoding为REDIS_ENCODING_HT即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个 SET 编码的集合对象
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createSetObject</span>(<span style="color:#66d9ef">void</span>) {

    dict <span style="color:#f92672">*</span>d <span style="color:#f92672">=</span> dictCreate(<span style="color:#f92672">&amp;</span>setDictType,NULL);

    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> createObject(REDIS_SET,d);

    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_HT;

    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div><h2 id="字符串对象">字符串对象</h2>
<p>字符串对象可以使用int、raw或者embstr编码来实现。当保存的是整数值时，用INT编码。当保存的是一个大于32字节的字符串，用RAW编码。当保存的是小于32字节的非整数值，使用EMBSTR编码。</p>
<p>REDIS_ENCODING_INT编码类型可以实现REDIS_STRING对象。在Redis中有共享整数池，如果需要的是这样的整数，可以直接返回共享整数。下面是分为三种情况根据整数值创建REDIS_STRING对象的方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 根据传入的整数值，创建一个字符串对象
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 这个字符串的对象保存的可以是 INT 编码的 long 值，
</span><span style="color:#75715e"> * 也可以是 RAW 编码的、被转换成字符串的 long long 值。
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createStringObjectFromLongLong</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> value) {

    robj <span style="color:#f92672">*</span>o;

    <span style="color:#75715e">// value 的大小符合 REDIS 共享整数的范围
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 那么返回一个共享对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> value <span style="color:#f92672">&lt;</span> REDIS_SHARED_INTEGERS) {
        incrRefCount(shared.integers[value]);
        o <span style="color:#f92672">=</span> shared.integers[value];

    <span style="color:#75715e">// 不符合共享范围，创建一个新的整数对象
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// 值可以用 long 类型保存，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 创建一个 REDIS_ENCODING_INT 编码的字符串对象
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&gt;=</span> LONG_MIN <span style="color:#f92672">&amp;&amp;</span> value <span style="color:#f92672">&lt;=</span> LONG_MAX) {
            o <span style="color:#f92672">=</span> createObject(REDIS_STRING, NULL);
            o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_INT;
            o<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)((<span style="color:#66d9ef">long</span>)value);

        <span style="color:#75715e">// 值不能用 long 类型保存（long long 类型），将值转换为字符串，
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 并创建一个 REDIS_ENCODING_RAW 的字符串对象来保存值
</span><span style="color:#75715e"></span>        } <span style="color:#66d9ef">else</span> {
            o <span style="color:#f92672">=</span> createObject(REDIS_STRING,sdsfromlonglong(value));
        }
    }

    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div><p>另外，Redis还有一个createStringObjectFromLongDouble方法，将double类型的数字转换成char数组，并包装成EMBSTR或者RAW编码的robj(在包装成robj的过程中，还是变成了SDS类型)。</p>
<p>下面是创建使用EMBSTR和RAW编码创建REDIS_STRING的调用方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createStringObject</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr, size_t len) {
    <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">&lt;=</span> REDIS_ENCODING_EMBSTR_SIZE_LIMIT)
        <span style="color:#66d9ef">return</span> createEmbeddedStringObject(ptr,len);
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> createRawStringObject(ptr,len);
}
</code></pre></div><p>REDIS_ENCODING_EMBSTR是用SDS实现的，下面的代码创建EmbeddedStringObject，输入的ptr是需要创建的字符串的指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象
</span><span style="color:#75715e">// 这个字符串对象中的 sds 会和字符串对象的 redisObject 结构一起分配
</span><span style="color:#75715e">// 因此这个字符也是不可修改的
</span><span style="color:#75715e"></span>robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createEmbeddedStringObject</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr, size_t len) {
<span style="color:#75715e">//    将robj和sdshdr的内存绑定在一起分配，分配好之后返回的是robj的指针。
</span><span style="color:#75715e"></span>    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(robj)<span style="color:#f92672">+</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> sdshdr)<span style="color:#f92672">+</span>len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
<span style="color:#75715e">//    o+1是跳过一个robj结构体的长度，返回的是sdshdr的头指针。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> sdshdr <span style="color:#f92672">*</span>sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)(o<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);

    o<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">=</span> REDIS_STRING;
    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_EMBSTR;
    o<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> sh<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    o<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    o<span style="color:#f92672">-&gt;</span>lru <span style="color:#f92672">=</span> LRU_CLOCK();

    sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> len;
    sh<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (ptr) {
        memcpy(sh<span style="color:#f92672">-&gt;</span>buf,ptr,len);
        sh<span style="color:#f92672">-&gt;</span>buf[len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    } <span style="color:#66d9ef">else</span> {
        memset(sh<span style="color:#f92672">-&gt;</span>buf,<span style="color:#ae81ff">0</span>,len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    }
    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div><p>使用RAW编码创建STRING对象，ptr指向的也是SDS，不同的是现在SDS和STRING对象的内存不绑定在一起了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Create a string object with encoding REDIS_ENCODING_RAW, that is a plain
</span><span style="color:#75715e"> * string object where o-&gt;ptr points to a proper sds string. */</span>
<span style="color:#75715e">// 创建一个 REDIS_ENCODING_RAW 编码的字符对象
</span><span style="color:#75715e">// 对象的指针指向一个 sds 结构
</span><span style="color:#75715e"></span>robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createRawStringObject</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptr, size_t len) {
    <span style="color:#66d9ef">return</span> createObject(REDIS_STRING,sdsnewlen(ptr,len));
}
</code></pre></div><h3 id="编码的转换">编码的转换</h3>
<p>在对long double类型进行操作的时候，程序会先将字符串转换回浮点数，进行修改之后再保存到字符串中。如果操作之后的结果不是整型或者long double了，那么就只能以RAW编码来保存了。</p>
<p>由于EMBSTR的内存是绑定的，无法修改，所以对EMBSTR进行操作之后，对象的编码就从EMBSTR转变成RAW了(上面的long double实际上是EMBSTR类型，所以和这里的情况相同，只能改编成RAW编码)。</p>
<h2 id="列表对象">列表对象</h2>
<p>列表对象的编码可以使ziplist或者linkedlist。ziplist内存紧凑，遍历迅速，但是可能会产生连锁修改的情况，修改元素也会导致内存申请，且在需要存储大量数据的时候不一定能申请到合适的内存。而linkedlist遍历速度慢，但是由于是链表，可以利用碎片内存。</p>
<p>对于RPUSH numbers 1 &ldquo;three&rdquo; 5这样的命令，看看不同编码的存储结果：在ziplist编码的时候，每个entry都得以有自己的编码，1以整型存储，&ldquo;trhee&quot;以字节数组形式存储。而linkedlist是统一编码，所以1这样的整数只能也以String的类型存在了。</p>
<p>列表对象默认在以下情况都满足的情况下使用ziplist，否则就使用linkedlist：</p>
<ol>
<li>所有字符串长度都小于64字节</li>
<li>保存的元素数量小于512个</li>
</ol>
<p>如果ziplist在修改的过程中不再满足以上的条件，也会被转换成linkedlist。</p>
<p>下面分别是使用linkedlist和ziplist创建List对象的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个 LINKEDLIST 编码的列表对象
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createListObject</span>(<span style="color:#66d9ef">void</span>) {

    list <span style="color:#f92672">*</span>l <span style="color:#f92672">=</span> listCreate();

    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> createObject(REDIS_LIST,l);

    listSetFreeMethod(l,decrRefCountVoid);

    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_LINKEDLIST;

    <span style="color:#66d9ef">return</span> o;
}

<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个 ZIPLIST 编码的列表对象
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createZiplistObject</span>(<span style="color:#66d9ef">void</span>) {

    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl <span style="color:#f92672">=</span> ziplistNew();

    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> createObject(REDIS_LIST,zl);

    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_ZIPLIST;

    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div><p>从listTypePush方法可以看到，在插入元素之前都会尝试转换编码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* The function pushes an element to the specified list object &#39;subject&#39;,
</span><span style="color:#75715e"> * at head or tail position as specified by &#39;where&#39;.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 将给定元素添加到列表的表头或表尾。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 参数 where 决定了新元素添加的位置：
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> *  - REDIS_HEAD 将新元素添加到表头
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> *  - REDIS_TAIL 将新元素添加到表尾
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * There is no need for the caller to increment the refcount of &#39;value&#39; as
</span><span style="color:#75715e"> * the function takes care of it if needed. 
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 调用者无须担心 value 的引用计数，因为这个函数会负责这方面的工作。
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listTypePush</span>(robj <span style="color:#f92672">*</span>subject, robj <span style="color:#f92672">*</span>value, <span style="color:#66d9ef">int</span> where) {

    <span style="color:#75715e">/* Check if we need to convert the ziplist */</span>
    <span style="color:#75715e">// 是否需要转换编码？
</span><span style="color:#75715e"></span>    listTypeTryConversion(subject,value);

    <span style="color:#66d9ef">if</span> (subject<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">==</span> REDIS_ENCODING_ZIPLIST <span style="color:#f92672">&amp;&amp;</span>
        ziplistLen(subject<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">&gt;=</span> server.list_max_ziplist_entries)
            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);

    <span style="color:#75715e">// ZIPLIST
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (subject<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">==</span> REDIS_ENCODING_ZIPLIST) {
        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> (where <span style="color:#f92672">==</span> REDIS_HEAD) <span style="color:#f92672">?</span> ZIPLIST_HEAD : ZIPLIST_TAIL;
        <span style="color:#75715e">// 取出对象的值，因为 ZIPLIST 只能保存字符串或整数
</span><span style="color:#75715e"></span>        value <span style="color:#f92672">=</span> getDecodedObject(value);
        subject<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> ziplistPush(subject<span style="color:#f92672">-&gt;</span>ptr,value<span style="color:#f92672">-&gt;</span>ptr,sdslen(value<span style="color:#f92672">-&gt;</span>ptr),pos);
        decrRefCount(value);

    <span style="color:#75715e">// 双端链表
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (subject<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">==</span> REDIS_ENCODING_LINKEDLIST) {
        <span style="color:#66d9ef">if</span> (where <span style="color:#f92672">==</span> REDIS_HEAD) {
            listAddNodeHead(subject<span style="color:#f92672">-&gt;</span>ptr,value);
        } <span style="color:#66d9ef">else</span> {
            listAddNodeTail(subject<span style="color:#f92672">-&gt;</span>ptr,value);
        }
        incrRefCount(value);

    <span style="color:#75715e">// 未知编码
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
        redisPanic(<span style="color:#e6db74">&#34;Unknown list encoding&#34;</span>);
    }
}




<span style="color:#75715e">/* Check the argument length to see if it requires us to convert the ziplist
</span><span style="color:#75715e"> * to a real list. Only check raw-encoded objects because integer encoded
</span><span style="color:#75715e"> * objects are never too long. 
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 对输入值 value 进行检查，看是否需要将 subject 从 ziplist 转换为双端链表，
</span><span style="color:#75715e"> * 以便保存值 value 。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 函数只对 REDIS_ENCODING_RAW 编码的 value 进行检查，
</span><span style="color:#75715e"> * 因为整数编码的值不可能超长。
</span><span style="color:#75715e"> * 从代码逻辑可以清楚发现转换成linkedlist编码的条件
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listTypeTryConversion</span>(robj <span style="color:#f92672">*</span>subject, robj <span style="color:#f92672">*</span>value) {

    <span style="color:#75715e">// 确保 subject 为 ZIPLIST 编码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (subject<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">!=</span> REDIS_ENCODING_ZIPLIST) <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">if</span> (sdsEncodedObject(value) <span style="color:#f92672">&amp;&amp;</span>
        <span style="color:#75715e">// 看字符串是否过长
</span><span style="color:#75715e"></span>        sdslen(value<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">&gt;</span> server.list_max_ziplist_value)
            <span style="color:#75715e">// 将编码转换为双端链表
</span><span style="color:#75715e"></span>            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);
}
</code></pre></div><p>将ziplist编码转换成linkedlist编码实际就是遍历ziplist并添加到linkedlist中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">
<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 将列表的底层编码从 ziplist 转换成双端链表
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listTypeConvert</span>(robj <span style="color:#f92672">*</span>subject, <span style="color:#66d9ef">int</span> enc) {

    listTypeIterator <span style="color:#f92672">*</span>li;

    listTypeEntry entry;

    redisAssertWithInfo(NULL,subject,subject<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> REDIS_LIST);

    <span style="color:#75715e">// 转换成双端链表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (enc <span style="color:#f92672">==</span> REDIS_ENCODING_LINKEDLIST) {

        list <span style="color:#f92672">*</span>l <span style="color:#f92672">=</span> listCreate();

        listSetFreeMethod(l,decrRefCountVoid);

        <span style="color:#75715e">/* listTypeGet returns a robj with incremented refcount */</span>
        <span style="color:#75715e">// 遍历 ziplist ，并将里面的值全部添加到双端链表中
</span><span style="color:#75715e"></span>        li <span style="color:#f92672">=</span> listTypeInitIterator(subject,<span style="color:#ae81ff">0</span>,REDIS_TAIL);
        <span style="color:#66d9ef">while</span> (listTypeNext(li,<span style="color:#f92672">&amp;</span>entry)) listAddNodeTail(l,listTypeGet(<span style="color:#f92672">&amp;</span>entry));
        listTypeReleaseIterator(li);

        <span style="color:#75715e">// 更新编码
</span><span style="color:#75715e"></span>        subject<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_LINKEDLIST;

        <span style="color:#75715e">// 释放原来的 ziplist
</span><span style="color:#75715e"></span>        zfree(subject<span style="color:#f92672">-&gt;</span>ptr);

        <span style="color:#75715e">// 更新对象值指针
</span><span style="color:#75715e"></span>        subject<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> l;

    } <span style="color:#66d9ef">else</span> {
        redisPanic(<span style="color:#e6db74">&#34;Unsupported list conversion&#34;</span>);
    }
}

</code></pre></div><h1 id="哈希对象">哈希对象</h1>
<p>哈希对象用ziplist或者hashtable实现。当键值对少于512并且键/值长度小于64字节的时候使用ziplist实现。hashtable的底层实现是字典。</p>
<p>哈希对象的ziplist实现：将键和值相邻存储在ziplist中，当需要增加键值的时候，先将键存放到ziplist尾，再将值存放到ziplist尾。当ziplist的条件不满足的时候，就会使用字典来实现哈希对象了。</p>
<p>下面是t_hash中set的逻辑代码，主要的逻辑都在处理ziplist的情况——首先遍历ziplist看有没有这个键，如果有就替代掉；如果没有就将键和值插入到最后。然后尝试转码成hashtable，如果不满足条件就直接转码。而hashtable实现则简单了许多，直接尝试Replace，如果替换成功则返回1，替换失败就返回0.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Add an element, discard the old if the key already exists.
</span><span style="color:#75715e"> * Return 0 on insert and 1 on update.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 将给定的 field-value 对添加到 hash 中，
</span><span style="color:#75715e"> * 如果 field 已经存在，那么删除旧的值，并关联新值。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * This function will take care of incrementing the reference count of the
</span><span style="color:#75715e"> * retained fields and value objects. 
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 这个函数负责对 field 和 value 参数进行引用计数自增。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 返回 0 表示元素已经存在，这次函数调用执行的是更新操作。
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * 返回 1 则表示函数执行的是新添加操作。
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashTypeSet</span>(robj <span style="color:#f92672">*</span>o, robj <span style="color:#f92672">*</span>field, robj <span style="color:#f92672">*</span>value) {
    <span style="color:#66d9ef">int</span> update <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">// 添加到 ziplist
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">==</span> REDIS_ENCODING_ZIPLIST) {
        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl, <span style="color:#f92672">*</span>fptr, <span style="color:#f92672">*</span>vptr;

        <span style="color:#75715e">// 解码成字符串或者数字
</span><span style="color:#75715e"></span>        field <span style="color:#f92672">=</span> getDecodedObject(field);
        value <span style="color:#f92672">=</span> getDecodedObject(value);

        <span style="color:#75715e">// 遍历整个 ziplist ，尝试查找并更新 field （如果它已经存在的话）
</span><span style="color:#75715e"></span>        zl <span style="color:#f92672">=</span> o<span style="color:#f92672">-&gt;</span>ptr;
        fptr <span style="color:#f92672">=</span> ziplistIndex(zl, ZIPLIST_HEAD);
        <span style="color:#66d9ef">if</span> (fptr <span style="color:#f92672">!=</span> NULL) {
            <span style="color:#75715e">// 定位到域 field
</span><span style="color:#75715e"></span>            fptr <span style="color:#f92672">=</span> ziplistFind(fptr, field<span style="color:#f92672">-&gt;</span>ptr, sdslen(field<span style="color:#f92672">-&gt;</span>ptr), <span style="color:#ae81ff">1</span>);
            <span style="color:#66d9ef">if</span> (fptr <span style="color:#f92672">!=</span> NULL) {
                <span style="color:#75715e">/* Grab pointer to the value (fptr points to the field) */</span>
                <span style="color:#75715e">// 定位到域的值
</span><span style="color:#75715e"></span>                vptr <span style="color:#f92672">=</span> ziplistNext(zl, fptr);
                redisAssert(vptr <span style="color:#f92672">!=</span> NULL);

                <span style="color:#75715e">// 标识这次操作为更新操作
</span><span style="color:#75715e"></span>                update <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

                <span style="color:#75715e">/* Delete value */</span>
                <span style="color:#75715e">// 删除旧的键值对
</span><span style="color:#75715e"></span>                zl <span style="color:#f92672">=</span> ziplistDelete(zl, <span style="color:#f92672">&amp;</span>vptr);

                <span style="color:#75715e">/* Insert new value */</span>
                <span style="color:#75715e">// 添加新的键值对
</span><span style="color:#75715e"></span>                zl <span style="color:#f92672">=</span> ziplistInsert(zl, vptr, value<span style="color:#f92672">-&gt;</span>ptr, sdslen(value<span style="color:#f92672">-&gt;</span>ptr));
            }
        }

        <span style="color:#75715e">// 如果这不是更新操作，那么这就是一个添加操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>update) {
            <span style="color:#75715e">/* Push new field/value pair onto the tail of the ziplist */</span>
            <span style="color:#75715e">// 将新的 field-value 对推入到 ziplist 的末尾
</span><span style="color:#75715e"></span>            zl <span style="color:#f92672">=</span> ziplistPush(zl, field<span style="color:#f92672">-&gt;</span>ptr, sdslen(field<span style="color:#f92672">-&gt;</span>ptr), ZIPLIST_TAIL);
            zl <span style="color:#f92672">=</span> ziplistPush(zl, value<span style="color:#f92672">-&gt;</span>ptr, sdslen(value<span style="color:#f92672">-&gt;</span>ptr), ZIPLIST_TAIL);
        }
        
        <span style="color:#75715e">// 更新对象指针
</span><span style="color:#75715e"></span>        o<span style="color:#f92672">-&gt;</span>ptr <span style="color:#f92672">=</span> zl;

        <span style="color:#75715e">// 释放临时对象
</span><span style="color:#75715e"></span>        decrRefCount(field);
        decrRefCount(value);

        <span style="color:#75715e">/* Check if the ziplist needs to be converted to a hash table */</span>
        <span style="color:#75715e">// 检查在添加操作完成之后，是否需要将 ZIPLIST 编码转换成 HT 编码
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (hashTypeLength(o) <span style="color:#f92672">&gt;</span> server.hash_max_ziplist_entries)
            hashTypeConvert(o, REDIS_ENCODING_HT);

    <span style="color:#75715e">// 添加到字典
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">==</span> REDIS_ENCODING_HT) {

        <span style="color:#75715e">// 添加或替换键值对到字典
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 添加返回 1 ，替换返回 0
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (dictReplace(o<span style="color:#f92672">-&gt;</span>ptr, field, value)) { <span style="color:#75715e">/* Insert */</span>
            incrRefCount(field);
        } <span style="color:#66d9ef">else</span> { <span style="color:#75715e">/* Update */</span>
            update <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }

        incrRefCount(value);
    } <span style="color:#66d9ef">else</span> {
        redisPanic(<span style="color:#e6db74">&#34;Unknown hash encoding&#34;</span>);
    }

    <span style="color:#75715e">// 更新/添加指示变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> update;
}
</code></pre></div><h1 id="集合对象">集合对象</h1>
<p>集合对象的编码可以是intset或者hashtable。</p>
<p>在元素都是整数且数量少于512的时候，集合对象使用intset。不满足这样的条件之后intset转为hashtable编码。</p>
<p>使用intset编码的时候，存储的都是整数类型。但是转换成hashtable编码的时候，元素被存储为StringObject类型的键，而值则是空，以此来保证元素的唯一性。</p>
<h1 id="有序集合对象">有序集合对象</h1>
<p>有序集合对象的编码是ziplist或者skiplist。</p>
<p>在ziplist中保存内容的方式是先保存成员，再保存分值。使用ziplist的条件是：元素数量少于128个并且长度小于64字节（为什么这里就是128呢？明明也是键-值对，好在意..）。</p>
<p>skiplist的底层实现是zset，每个键都是StringObject对象，而值都是double对象。一个zset结构同时包括一个字典和一个跳跃表，他们使用的指针指向同一个的键、值对象，所以不会有多余的内存浪费和不一致问题。同时包括字典和跳跃表是为了提高效率：在查找某个成员的分值的时候使用字典，在进行排序、范围操作的时候使用跳跃表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 有序集合
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> zset {

    <span style="color:#75715e">// 字典，键为成员，值为分值
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 用于支持 O(1) 复杂度的按成员取分值操作
</span><span style="color:#75715e"></span>    dict <span style="color:#f92672">*</span>dict;

    <span style="color:#75715e">// 跳跃表，按分值排序成员
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 用于支持平均复杂度为 O(log N) 的按分值定位成员操作
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 以及范围操作
</span><span style="color:#75715e"></span>    zskiplist <span style="color:#f92672">*</span>zsl;

} zset;
</code></pre></div><p>下面的代码是分别使用SKIPLIST和ZIPLIST编码创建有序集合的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个 SKIPLIST 编码的有序集合
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createZsetObject</span>(<span style="color:#66d9ef">void</span>) {

<span style="color:#75715e">//  创建ZSET
</span><span style="color:#75715e"></span>    zset <span style="color:#f92672">*</span>zs <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>zs));

    robj <span style="color:#f92672">*</span>o;

<span style="color:#75715e">//  分别初始化dict和跳跃表
</span><span style="color:#75715e"></span>    zs<span style="color:#f92672">-&gt;</span>dict <span style="color:#f92672">=</span> dictCreate(<span style="color:#f92672">&amp;</span>zsetDictType,NULL);
    zs<span style="color:#f92672">-&gt;</span>zsl <span style="color:#f92672">=</span> zslCreate();

    o <span style="color:#f92672">=</span> createObject(REDIS_ZSET,zs);

    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_SKIPLIST;

    <span style="color:#66d9ef">return</span> o;
}

<span style="color:#75715e">/*
</span><span style="color:#75715e"> * 创建一个 ZIPLIST 编码的有序集合
</span><span style="color:#75715e"> */</span>
robj <span style="color:#f92672">*</span><span style="color:#a6e22e">createZsetZiplistObject</span>(<span style="color:#66d9ef">void</span>) {

    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl <span style="color:#f92672">=</span> ziplistNew();

    robj <span style="color:#f92672">*</span>o <span style="color:#f92672">=</span> createObject(REDIS_ZSET,zl);

    o<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> REDIS_ENCODING_ZIPLIST;

    <span style="color:#66d9ef">return</span> o;
}
</code></pre></div></article>
    </section>

    <footer class="ui attached segment dream-tags">
      
        
          <a class="ui label" href="/tags/redis" title="Redis">Redis</a>
        
          <a class="ui label" href="/tags/%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
        
      
      <div
        class="ui label"
        style="float: right; background: #1b1c1d !important; cursor: pointer;"
        onclick="savePostAsImg()">
        <i class="save icon"></i> Save as image
      </div>
    </footer>

    
      <footer class="ui attached segment">
        <strong>欢迎通过<a href="mailto:shen_jianan@foxmail.com">邮箱</a>(shen_jianan@foxmail.com)探讨问题</strong> <br/><br/><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。 <br />
      </footer>
    

    

  </div>
  <div class="sixteen wide mobile sixteen wide tablet four wide computer column">
    <article class="dream-header">
  <section class="ui top attached center aligned segment">
    <div class="ui small circular image">
      
        <img src="https://shenjianan-blog.oss-cn-beijing.aliyuncs.com/avatars/totoro3.jpeg?x-oss-process=style/compress">
      
    </div>

    <h1 class="ui medium header">Shen Jianan&#39;s blog<div class="sub header" style="margin-top: 0.5rem;">Freedom as Autonomy</div>
    </h1>

    <div class="ui horizontal list">
      
      <a class="item" href="/posts">
        <i class="archive icon" title="Archives"></i>
      </a>
      
      <a class="item" href="/tags">
        <i class="tags icon" title="All Tags"></i>
      </a>
      <a class="item" href="/categories">
        <i class="th list icon" title="All Categories"></i>
      </a>
    </div>
  </section>

  
  <section class="ui attached center aligned segment dream-tags">
    
      <a class="ui label" href="/tags/hbase" title="hbase">hbase</a>
    
      <a class="ui label" href="/tags/java" title="java">java</a>
    
      <a class="ui label" href="/tags/redis" title="redis">redis</a>
    
      <a class="ui label" href="/tags/ruby" title="ruby">ruby</a>
    
      <a class="ui label" href="/tags/%E4%B9%A0%E9%A2%98" title="习题">习题</a>
    
      <a class="ui label" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F" title="分布式">分布式</a>
    
      <a class="ui label" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" title="机器学习">机器学习</a>
    
      <a class="ui label" href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" title="神经网络">神经网络</a>
    
      <a class="ui label" href="/tags/%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
    
      <a class="ui label" href="/tags/%E7%AE%97%E6%B3%95" title="算法">算法</a>
    
      <a class="ui label" href="/tags/%E7%AE%97%E6%B3%95%E5%BC%95%E6%93%8E" title="算法引擎">算法引擎</a>
    
      <a class="ui label" href="/tags/%E8%AE%BA%E6%96%87" title="论文">论文</a>
    
  </section>
  

  
  <section class="ui attached segment dream-categories">
    <div class="ui accordion">
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/java" class="item">java</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="item">Java并发编程实战 读书笔记</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/redis" class="item">redis</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6/" class="item">Redis设计与实现——事件</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0aof%E6%8C%81%E4%B9%85%E5%8C%96/" class="item">Redis设计与实现——AOF持久化</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0rdb%E6%8C%81%E4%B9%85%E5%8C%96/" class="item">Redis设计与实现——RDB持久化</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%97%E8%A1%A8%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/" class="item">Redis设计与实现——数据库列表与结构体</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0sds%E5%93%88%E5%B8%8C%E8%A1%A8/" class="item">Redis设计与实现——SDS哈希表</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0sds%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="item">Redis设计与实现——SDS实现与代码解读</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/ruby" class="item">ruby</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/ruby/ruby%E5%85%83%E7%BC%96%E7%A8%8B-week-5/" class="item">Ruby元编程 星期五</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/ruby/ruby%E5%85%83%E7%BC%96%E7%A8%8B-week-4/" class="item">Ruby元编程 星期四</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/ruby/ruby%E5%85%83%E7%BC%96%E7%A8%8B-week-3/" class="item">Ruby元编程 星期三</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/ruby/ruby%E5%85%83%E7%BC%96%E7%A8%8B-week-2/" class="item">Ruby元编程 星期二</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/ruby/ruby%E5%85%83%E7%BC%96%E7%A8%8B-week-1/" class="item">Ruby元编程 星期一</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/%E4%B9%A0%E9%A2%98" class="item">习题</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/exercises/2020-11-07/" class="item">习题2020-11-07</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F" class="item">分布式</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/distributed/raft%E6%A6%82%E8%AE%BA/" class="item">Raft概论</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/distributed/bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91/" class="item">BigTable论文阅读&amp;个人翻译</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/distributed/hbase%E5%AE%9E%E6%88%98%E9%9A%8F%E7%AC%94%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/" class="item">《HBase实战》随笔——数据操作</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" class="item">机器学习</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E4%BC%98%E5%8C%96%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="item">优化神经网络表现的几种方法</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%83%8C%E5%90%8E%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%AD%89%E5%BC%8F/" class="item">反向传播背后的四个基本等式</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="item">神经网络基础知识</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-ex6/" class="item">机器学习 ex6</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E6%A0%B8%E5%87%BD%E6%95%B0/" class="item">核函数</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/machinelearning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="item">神经网络反向传播计算过程笔记</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/%E7%AE%97%E6%B3%95" class="item">算法</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/algorithm/%E5%86%8D%E6%8E%A2%E6%8E%92%E5%BA%8F/" class="item">再探排序</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B0%8F%E7%BB%93/" class="item">简单搜索二叉树&amp;红黑树小结</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/algorithm/%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F/" class="item">线性时间排序</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/" class="item">快速排序算法小结</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="/categories/%E7%AE%97%E6%B3%95%E5%BC%95%E6%93%8E" class="item">算法引擎</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="http://www.shenjianan.top/posts/algorithmengine/faiss%E5%90%91%E9%87%8F%E5%8F%AC%E5%9B%9E%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%9C%80%E8%BF%91%E9%82%BB/" class="item">Faiss向量召回引擎如何做到快速查找最近邻</a>
              </div>
            </div>
          
          </div>
        </div>
      
    </div>
  </section>
  

  <section class="ui attached segment header-socials">
    <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <i class=" mail icon" title="email"></i> 
      <a href="mailto:shen_jianan@foxmail.com">
        shen_jianan@foxmail.com
      </a>
    </div>
  

  

  

  

  

  

  

  
</nav>

  </section>

  <section class="ui bottom attached center aligned segment">
    
      <p>© 2015 - 2020 Shen Jianan的随缘更新</p>
    

    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>
  </section>
</article>


  </div>
</div>

        </section>
        <section class="back">
          
<nav class="ui secondary menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="Flip it!"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="Home" onclick="window.location.href = 'http:\/\/www.shenjianan.top\/'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          <div class="ui centered relaxed grid dream-grid dream-back">
  
    <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
      <article>
        <div class="ui top attached segment">
          <h3 class="ui header">About Me</h3>
        </div>
        <div class="ui attached segment markdown-body">
          <h4 id="201802至今emsp杭州嘉云数据-算法引擎">2018.02至今 杭州嘉云数据 算法引擎</h4>
<h4 id="20176-201712emsp菜网络-工智能部-算法引擎">2017.6-2017.12 菜⻦网络-⼈工智能部-算法引擎</h4>
<h4 id="201609-201806emsp南京大学研究生">2016.09-2018.06 南京大学研究生</h4>
<h4 id="201507-201509emsp阿里巴巴-icbu-实习">2015.07-2015.09 阿里巴巴-ICBU-实习</h4>
<h4 id="201209-201606emsp南京大学本科">2012.09-2016.06 南京大学本科</h4>

        </div>
      </article>
    </section>
  

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article>
      <div class="ui top attached segment">
        <h3 class="ui header">Social Links</h3>
      </div>
      <div class="ui attached segment">
        <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <i class="large mail icon" title="email"></i> 
      <a href="mailto:shen_jianan@foxmail.com">
        shen_jianan@foxmail.com
      </a>
    </div>
  

  

  

  

  

  

  

  
</nav>

      </div>
    </article>
  </section>

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
      <footer class="ui segment">
        <strong>欢迎通过<a href="mailto:shen_jianan@foxmail.com">邮箱</a>(shen_jianan@foxmail.com)探讨问题</strong> <br/><br/><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。 <br />
      </footer>
    
  </section>

  
  
</div>

        </section>
      </div>
    </div>

    <script src="/js/jquery.min.js"></script>
<script src="/js/semantic.min.js"></script>
<script src="/js/imagesloaded.pkgd.min.js"></script>
<script src="/js/masonry.pkgd.min.js"></script>
<script src="/js/nav.js"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>
<script src="/js/html2canvas.min.js"></script>



  </body>
</html>
